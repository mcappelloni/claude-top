#!/usr/bin/env python3
"""
claude-top: A terminal-based monitoring tool for Claude CLI instances
"""

import curses
import json
import os
import psutil
import signal
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Dict
from collections import deque
import subprocess
import argparse

# Import database tracking components
try:
    from database_schema import ClaudeDatabase
    from process_tree import ProcessTreeTracker
    from analytics import ClaudeAnalytics
    DATABASE_AVAILABLE = True
except ImportError:
    DATABASE_AVAILABLE = False

@dataclass
class ClaudeInstance:
    pid: int
    working_dir: str
    task: str
    context_length: int
    tokens_used: int
    start_time: datetime
    status: str  # 'running', 'idle', 'waiting', 'paused'
    cpu_percent: float
    memory_mb: float
    command: str
    cpu_history: deque = field(default_factory=lambda: deque(maxlen=5))
    net_bytes_sent: int = 0
    net_bytes_recv: int = 0
    net_bytes_total: int = 0
    disk_total_bytes: int = 0
    disk_current_bytes: int = 0  # Current cycle activity
    connections_count: int = 0
    mcp_connections: int = 0

class ClaudeMonitor:
    def __init__(self, enable_database: bool = True):
        self.instances: List[ClaudeInstance] = []
        self.selected_index = 0
        self.paused_pids = set()
        self.update_interval = 1.0
        self.sort_key = 'pid'
        self.reverse_sort = False
        self.show_full_path = False
        self.cpu_histories = {}  # Track CPU history for each PID
        self.group_by_project = False
        self.project_groups = {}  # project_path -> list of instances
        
        # Database tracking
        self.enable_database = enable_database and DATABASE_AVAILABLE
        self.db = None
        self.tree_tracker = None
        self.active_sessions = {}  # pid -> session_id
        self.project_cache = {}    # working_dir -> project_id
        
        if self.enable_database:
            try:
                self.db = ClaudeDatabase()
                self.tree_tracker = ProcessTreeTracker()
            except Exception as e:
                print(f"Warning: Database initialization failed: {e}")
                self.enable_database = False
        
    def find_claude_processes(self):
        """Find all Claude CLI processes running on the system"""
        claude_processes = []
        current_pid = os.getpid()  # Get claude-top's own PID
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cwd', 'create_time', 'cpu_percent', 'memory_info']):
            try:
                # Skip our own process (claude-top)
                if proc.info['pid'] == current_pid:
                    continue
                
                # Check if this is a Claude CLI process
                cmdline = proc.info.get('cmdline', [])
                if cmdline and any('claude' in cmd.lower() for cmd in cmdline):
                    # Filter out non-CLI Claude processes
                    cmdline_str = ' '.join(cmdline)
                    
                    # Skip Claude desktop app processes
                    if 'Claude.app' in cmdline_str or 'Claude Helper' in cmdline_str or 'chrome_crashpad' in cmdline_str or 'Squirrel' in cmdline_str:
                        continue
                    
                    # Skip claude-top itself (additional check by command)
                    if 'claude-top' in cmdline_str or './claude-top' in cmdline_str:
                        continue
                    
                    # Skip docker processes unless they're Claude-related containers
                    if 'docker' in cmdline_str and 'mcp/filesystem' in cmdline_str:
                        continue
                    
                    # Extract relevant information
                    instance = self.parse_claude_process(proc)
                    if instance:
                        claude_processes.append(instance)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        # Database tracking
        if self.enable_database and self.db:
            self.track_processes_in_database(claude_processes)
                
        return claude_processes
    
    def track_processes_in_database(self, instances: List[ClaudeInstance]):
        """Track processes in database"""
        try:
            current_pids = {inst.pid for inst in instances}
            
            # End sessions for processes that are no longer running
            ended_pids = set(self.active_sessions.keys()) - current_pids
            for pid in ended_pids:
                session_id = self.active_sessions[pid]
                self.db.end_session(session_id)
                del self.active_sessions[pid]
            
            # Start sessions for new processes and record metrics for all
            for instance in instances:
                if instance.pid not in self.active_sessions:
                    # Start new session
                    project_id = self.get_or_create_project(instance.working_dir)
                    session_id = self.db.start_session(
                        instance.pid, 
                        project_id, 
                        instance.command
                    )
                    self.active_sessions[instance.pid] = session_id
                
                # Record current metrics
                session_id = self.active_sessions[instance.pid]
                metrics = {
                    'cpu_percent': instance.cpu_percent,
                    'memory_mb': instance.memory_mb,
                    'net_bytes_sent': instance.net_bytes_sent,
                    'net_bytes_recv': instance.net_bytes_recv,
                    'net_bytes_total': instance.net_bytes_total,
                    'disk_total_bytes': instance.disk_total_bytes,
                    'disk_current_bytes': instance.disk_current_bytes,
                    'connections_count': instance.connections_count,
                    'mcp_connections': instance.mcp_connections,
                    'status': instance.status
                }
                self.db.record_metrics(session_id, metrics)
        except Exception as e:
            # Don't let database errors break the monitoring
            pass
    
    def get_or_create_project(self, working_dir: str) -> int:
        """Get or create project with caching"""
        if working_dir in self.project_cache:
            return self.project_cache[working_dir]
        
        project_id = self.db.get_or_create_project(working_dir)
        self.project_cache[working_dir] = project_id
        return project_id
    
    def calculate_summary_stats(self, instances: List[ClaudeInstance]) -> Dict[str, any]:
        """Calculate comprehensive summary statistics for all Claude instances"""
        if not instances:
            return {
                'session_totals': {'net_in': 0, 'net_out': 0, 'net_total': 0, 'disk_total': 0, 'disk_current': 0},
                'current_rates': {'net_in_rate': 0, 'net_out_rate': 0, 'disk_rate': 0},
                'cpu_stats': {'current': 0, 'average': 0, 'count_running': 0, 'count_idle': 0, 'count_waiting': 0},
                'memory_stats': {'current': 0, 'average': 0, 'peak': 0},
                'process_stats': {'total': 0, 'with_mcp': 0, 'total_connections': 0},
                'historical_averages': {'cpu': 0, 'memory': 0, 'sessions': 0}
            }
        
        # Session totals (cumulative across all processes)
        session_totals = {
            'net_in': sum(inst.net_bytes_recv for inst in instances),
            'net_out': sum(inst.net_bytes_sent for inst in instances), 
            'net_total': sum(inst.net_bytes_total for inst in instances),
            'disk_total': sum(inst.disk_total_bytes for inst in instances),
            'disk_current': sum(inst.disk_current_bytes for inst in instances)
        }
        
        # Current rates (current cycle activity)
        current_rates = {
            'net_in_rate': session_totals['net_in'],  # Current cycle in
            'net_out_rate': session_totals['net_out'], # Current cycle out
            'disk_rate': session_totals['disk_current']  # Current cycle disk
        }
        
        # CPU statistics
        cpu_values = [inst.cpu_percent for inst in instances]
        cpu_stats = {
            'current': sum(cpu_values),
            'average': sum(cpu_values) / len(cpu_values) if cpu_values else 0,
            'count_running': sum(1 for inst in instances if inst.status == 'running'),
            'count_idle': sum(1 for inst in instances if inst.status == 'idle'),
            'count_waiting': sum(1 for inst in instances if inst.status == 'waiting'),
            'count_paused': sum(1 for inst in instances if inst.status == 'paused')
        }
        
        # Memory statistics
        memory_values = [inst.memory_mb for inst in instances]
        memory_stats = {
            'current': sum(memory_values),
            'average': sum(memory_values) / len(memory_values) if memory_values else 0,
            'peak': max(memory_values) if memory_values else 0
        }
        
        # Process statistics
        process_stats = {
            'total': len(instances),
            'with_mcp': sum(1 for inst in instances if inst.mcp_connections > 0),
            'total_connections': sum(inst.connections_count for inst in instances)
        }
        
        # Historical averages from database
        historical_averages = {'cpu': 0, 'memory': 0, 'sessions': 0}
        if self.enable_database and self.db:
            try:
                from analytics import ClaudeAnalytics
                analytics = ClaudeAnalytics(self.db.db_path)
                reports = analytics.generate_usage_report(7)  # Last 7 days
                if reports:
                    historical_averages = {
                        'cpu': sum(r.avg_cpu_percent for r in reports) / len(reports),
                        'memory': sum(r.avg_memory_mb for r in reports) / len(reports),
                        'sessions': sum(r.session_count for r in reports)
                    }
            except:
                pass
        
        return {
            'session_totals': session_totals,
            'current_rates': current_rates,
            'cpu_stats': cpu_stats,
            'memory_stats': memory_stats,
            'process_stats': process_stats,
            'historical_averages': historical_averages
        }
    
    def parse_claude_process(self, proc) -> Optional[ClaudeInstance]:
        """Parse process information to create ClaudeInstance"""
        try:
            info = proc.info
            pid = info['pid']
            # Get working directory - try multiple methods
            cwd = info.get('cwd', None)
            if not cwd or cwd == '/':
                try:
                    # Try to get cwd directly from process
                    cwd = proc.cwd()
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    cwd = 'Unknown'
            
            cmdline = ' '.join(info.get('cmdline', []))
            
            # For now, we'll use a placeholder for task
            task = "Active Session"
            
            # Token/context information not available from external sources
            context_length, tokens_used = 0, 0
            
            # Initialize CPU history for new processes
            if pid not in self.cpu_histories:
                self.cpu_histories[pid] = deque(maxlen=5)
            
            # Update CPU history
            current_cpu = info.get('cpu_percent', 0.0)
            self.cpu_histories[pid].append(current_cpu)
            
            # Determine status based on CPU usage patterns
            status = self.determine_process_status(pid, proc)
            
            # Get network and disk I/O statistics
            net_io, disk_io, connections_info = self.get_io_stats(proc)
            
            return ClaudeInstance(
                pid=pid,
                working_dir=cwd,
                task=task,
                context_length=context_length,
                tokens_used=tokens_used,
                start_time=datetime.fromtimestamp(info['create_time']),
                status=status,
                cpu_percent=info.get('cpu_percent', 0.0),
                memory_mb=info.get('memory_info').rss / 1024 / 1024 if info.get('memory_info') else 0,
                command=cmdline,
                cpu_history=self.cpu_histories[pid].copy(),
                net_bytes_sent=net_io['bytes_sent'],
                net_bytes_recv=net_io['bytes_recv'],
                net_bytes_total=net_io['bytes_total'],
                disk_total_bytes=disk_io['total_bytes'],
                disk_current_bytes=disk_io['current_bytes'],
                connections_count=connections_info['total_connections'],
                mcp_connections=connections_info['mcp_connections']
            )
        except Exception:
            return None
    
    def extract_task_from_cmdline(self, cmdline: str) -> str:
        """Extract task description from command line"""
        # This is a simplified extraction - in reality, you'd parse Claude's specific format
        if '--task' in cmdline:
            parts = cmdline.split('--task')
            if len(parts) > 1:
                return parts[1].split()[0].strip('"\'')
        elif 'claude' in cmdline:
            # Try to extract any quoted strings as potential tasks
            import re
            quotes = re.findall(r'"([^"]*)"', cmdline)
            if quotes:
                return quotes[0][:50] + '...' if len(quotes[0]) > 50 else quotes[0]
        return "Unknown Task"
    
    def get_claude_metrics(self, pid: int, working_dir: str) -> tuple:
        """Token/context information not available from external sources"""
        # Claude CLI does not expose token/context data in accessible files
        # This information is only available internally via /cost command
        return 0, 0
    
    def get_io_stats(self, proc):
        """Get network I/O, disk I/O, and connection statistics for a process"""
        try:
            pid = proc.pid
            
            # Initialize I/O tracker if not exists
            if not hasattr(self, 'io_tracker'):
                self.io_tracker = {}
            if not hasattr(self, 'io_totals'):
                self.io_totals = {}
            
            # Get current activity indicators
            current_indicators = self.get_activity_indicators(proc)
            
            # Calculate I/O estimates based on activity changes
            if pid in self.io_tracker:
                prev_indicators = self.io_tracker[pid]
                
                # Memory delta often indicates I/O activity
                memory_delta = current_indicators.get('memory_usage', 0) - prev_indicators.get('memory_usage', 0)
                files_delta = current_indicators.get('open_files', 0) - prev_indicators.get('open_files', 0)
                
                # Estimate current cycle disk I/O
                estimated_write = max(0, memory_delta // 10)  # Memory growth -> writes
                estimated_read = abs(files_delta) * 1024  # File activity -> reads
                current_disk_io = estimated_write + estimated_read
                
                # Network estimation based on connection activity and CPU
                conn_count = current_indicators.get('network_connections', 0)
                cpu_factor = max(1, current_indicators.get('cpu_percent', 0) / 10)  # CPU activity affects network
                base_net_activity = conn_count * 1024 * cpu_factor  # More sophisticated estimate
                
                current_net_sent = int(base_net_activity * 0.6)  # Assume more outbound (requests)
                current_net_recv = int(base_net_activity * 0.4)  # Less inbound (responses)
                
                # Update totals
                if pid not in self.io_totals:
                    self.io_totals[pid] = {
                        'total_net_sent': 0, 'total_net_recv': 0, 'total_disk': 0
                    }
                
                self.io_totals[pid]['total_net_sent'] += current_net_sent
                self.io_totals[pid]['total_net_recv'] += current_net_recv
                self.io_totals[pid]['total_disk'] += current_disk_io
                
                net_stats = {
                    'bytes_sent': current_net_sent,
                    'bytes_recv': current_net_recv,
                    'bytes_total': self.io_totals[pid]['total_net_sent'] + self.io_totals[pid]['total_net_recv']
                }
                
                disk_stats = {
                    'total_bytes': self.io_totals[pid]['total_disk'],
                    'current_bytes': current_disk_io
                }
            else:
                # First time seeing this process
                net_stats = {'bytes_sent': 0, 'bytes_recv': 0, 'bytes_total': 0}
                disk_stats = {'total_bytes': 0, 'current_bytes': 0}
                if pid not in self.io_totals:
                    self.io_totals[pid] = {
                        'total_net_sent': 0, 'total_net_recv': 0, 'total_disk': 0
                    }
            
            # Store current indicators for next comparison
            self.io_tracker[pid] = current_indicators
            
            # Connection analysis
            connections_info = {
                'total_connections': current_indicators.get('network_connections', 0),
                'mcp_connections': self.detect_mcp_connections(proc)
            }
            
            return net_stats, disk_stats, connections_info
            
        except Exception:
            # Return default values on any error
            return ({'bytes_sent': 0, 'bytes_recv': 0, 'bytes_total': 0}, 
                   {'total_bytes': 0, 'current_bytes': 0},
                   {'total_connections': 0, 'mcp_connections': 0})
    
    def get_activity_indicators(self, proc):
        """Get activity indicators for a process"""
        indicators = {
            'memory_usage': 0,
            'open_files': 0,
            'threads': 0,
            'network_connections': 0,
            'cpu_percent': 0
        }
        
        try:
            # Memory usage
            memory_info = proc.memory_info()
            indicators['memory_usage'] = memory_info.rss
            
            # CPU usage
            indicators['cpu_percent'] = proc.cpu_percent()
            
            # Thread count
            indicators['threads'] = proc.num_threads()
            
            # Open files count
            try:
                open_files = proc.open_files()
                indicators['open_files'] = len(open_files)
            except psutil.AccessDenied:
                pass
            
            # Network connections
            try:
                connections = proc.net_connections()
                indicators['network_connections'] = len(connections)
            except psutil.AccessDenied:
                pass
                
        except psutil.NoSuchProcess:
            pass
        
        return indicators
    
    def detect_mcp_connections(self, proc):
        """Detect potential MCP connections"""
        try:
            connections = proc.net_connections()
            mcp_count = 0
            
            for conn in connections:
                if conn.status == 'ESTABLISHED':
                    # Heuristic for MCP: WebSocket-like ports or specific patterns
                    if (conn.raddr and conn.raddr.port in [8000, 8080, 3000, 9000] or
                        (conn.laddr and conn.laddr.port > 8000)):
                        mcp_count += 1
            
            return mcp_count
        except (psutil.AccessDenied, AttributeError):
            return 0
    
    def pause_resume_process(self, pid: int):
        """Pause or resume a process"""
        try:
            if pid in self.paused_pids:
                os.kill(pid, signal.SIGCONT)
                self.paused_pids.remove(pid)
            else:
                os.kill(pid, signal.SIGSTOP)
                self.paused_pids.add(pid)
        except Exception as e:
            return f"Error: {str(e)}"
        return None

    def kill_process(self, pid: int, force=False):
        """Kill a process gracefully (SIGTERM) or forcefully (SIGKILL)"""
        try:
            proc = psutil.Process(pid)
            
            if force:
                # Force kill with SIGKILL
                proc.kill()
                return None, "Process killed forcefully (SIGKILL)"
            else:
                # Graceful termination with SIGTERM
                proc.terminate()
                return None, "Process terminated gracefully (SIGTERM)"
                
        except psutil.NoSuchProcess:
            return f"Process {pid} no longer exists", None
        except psutil.AccessDenied:
            return f"Access denied to process {pid}", None
        except Exception as e:
            return f"Error killing process {pid}: {str(e)}", None
    
    def determine_process_status(self, pid, proc):
        """Determine process status based on CPU usage patterns
        
        States:
        - running: Actively processing (>5% CPU)
        - waiting: In conversation, waiting for user input (<0.5% CPU, recent activity)
        - idle: Between sessions, waiting for new instructions (<0.5% CPU, no recent activity)
        - paused: Manually paused or system stopped
        """
        # Check if manually paused
        if pid in self.paused_pids:
            return 'paused'
        
        # Check system status
        sys_status = proc.status()
        if sys_status == 'stopped':
            return 'paused'
        
        # Analyze CPU history
        cpu_samples = list(self.cpu_histories[pid])
        if len(cpu_samples) >= 3:
            avg_cpu = sum(cpu_samples) / len(cpu_samples)
            max_cpu = max(cpu_samples)
            recent_cpu = cpu_samples[-1] if cpu_samples else 0
            
            # Check patterns in CPU history
            recent_samples = cpu_samples[-3:] if len(cpu_samples) >= 3 else cpu_samples
            recent_avg = sum(recent_samples) / len(recent_samples) if recent_samples else 0
            
            # Look for transition from active to idle (indicates waiting)
            had_activity = any(sample > 3.0 for sample in cpu_samples[:-2]) if len(cpu_samples) > 2 else False
            now_idle = recent_avg < 0.5
            
            if avg_cpu > 5.0:
                return 'running'  # Actively processing
            elif recent_avg < 0.5:
                # Very low recent CPU
                if had_activity and max_cpu > 3.0:
                    # Had significant activity before becoming idle - waiting for input
                    return 'waiting'
                elif recent_cpu > 0.2 or any(s > 0.5 for s in recent_samples):
                    # Still has minimal activity - likely waiting
                    return 'waiting'
                else:
                    # No recent activity at all - idle between sessions
                    return 'idle'
            else:
                # Medium CPU (0.5-5.0) - processing
                return 'running'
        
        # Default to running for new processes
        return 'running'
    
    def sort_instances(self):
        """Sort instances by the current sort key"""
        if self.sort_key == 'pid':
            self.instances.sort(key=lambda x: x.pid, reverse=self.reverse_sort)
        elif self.sort_key == 'cpu':
            self.instances.sort(key=lambda x: x.cpu_percent, reverse=self.reverse_sort)
        elif self.sort_key == 'memory':
            self.instances.sort(key=lambda x: x.memory_mb, reverse=self.reverse_sort)
        elif self.sort_key == 'net_out':
            self.instances.sort(key=lambda x: x.net_bytes_sent, reverse=self.reverse_sort)
        elif self.sort_key == 'net_in':
            self.instances.sort(key=lambda x: x.net_bytes_recv, reverse=self.reverse_sort)
        elif self.sort_key == 'net_total':
            self.instances.sort(key=lambda x: x.net_bytes_total, reverse=self.reverse_sort)
        elif self.sort_key == 'disk_total':
            self.instances.sort(key=lambda x: x.disk_total_bytes, reverse=self.reverse_sort)
        elif self.sort_key == 'disk_current':
            self.instances.sort(key=lambda x: x.disk_current_bytes, reverse=self.reverse_sort)
        elif self.sort_key == 'connections':
            self.instances.sort(key=lambda x: x.connections_count, reverse=self.reverse_sort)
        elif self.sort_key == 'time':
            self.instances.sort(key=lambda x: x.start_time, reverse=self.reverse_sort)
    
    def group_instances_by_project(self):
        """Group instances by their working directory (project)"""
        self.project_groups.clear()
        
        for instance in self.instances:
            # Use parent directory as project identifier
            project_path = os.path.dirname(instance.working_dir)
            if project_path not in self.project_groups:
                self.project_groups[project_path] = []
            self.project_groups[project_path].append(instance)
        
        # Sort instances within each group
        for project, instances in self.project_groups.items():
            if self.sort_key == 'pid':
                instances.sort(key=lambda x: x.pid, reverse=self.reverse_sort)
            elif self.sort_key == 'cpu':
                instances.sort(key=lambda x: x.cpu_percent, reverse=self.reverse_sort)
            elif self.sort_key == 'memory':
                instances.sort(key=lambda x: x.memory_mb, reverse=self.reverse_sort)
            # ... other sort options

class ClaudeTopUI:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.monitor = ClaudeMonitor()
        self.setup_colors()
        self.error_message = ""
        self.show_help = False
        self.search_mode = False
        self.search_query = ""
        self.filtered_instances = []
        self.selected_instances = set()  # For batch operations
        self.multi_select_mode = False
        
    def setup_colors(self):
        """Initialize color pairs"""
        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Running
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Paused
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)  # High CPU/Memory
        curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)  # Header
        curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLUE)  # Selected
    
    def format_bytes(self, bytes_value):
        """Format bytes into human readable format"""
        if bytes_value == 0:
            return "0B"
        elif bytes_value < 1024:
            return f"{bytes_value}B"
        elif bytes_value < 1024 * 1024:
            return f"{bytes_value/1024:.1f}K"
        elif bytes_value < 1024 * 1024 * 1024:
            return f"{bytes_value/(1024*1024):.1f}M"
        else:
            return f"{bytes_value/(1024*1024*1024):.1f}G"
    
    def create_usage_bar(self, percentage: float, width: int = 20) -> str:
        """Create a htop-style usage bar"""
        filled = int((percentage / 100.0) * width)
        bar = "█" * filled + "░" * (width - filled)
        return f"[{bar}]"
        
    def draw_header(self):
        """Draw the header with title and htop-style summary"""
        height, width = self.stdscr.getmaxyx()
        
        # Calculate summary statistics
        stats = self.monitor.calculate_summary_stats(self.monitor.instances)
        
        # Title
        title = "═══ Claude-Top - Claude CLI Monitor ═══"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(0, (width - len(title)) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # Left column - Process and CPU stats
        left_col = 2
        self.stdscr.addstr(1, left_col, f"Processes: {stats['process_stats']['total']} total")
        self.stdscr.addstr(2, left_col, f"  Running: {stats['cpu_stats']['count_running']}  Idle: {stats['cpu_stats']['count_idle']}  Waiting: {stats['cpu_stats']['count_waiting']}")
        
        # CPU usage bar (similar to htop)
        cpu_percent = min(stats['cpu_stats']['current'], 100.0)
        cpu_bar = self.create_usage_bar(cpu_percent, 30)
        self.stdscr.addstr(3, left_col, f"CPU: {cpu_percent:5.1f}% {cpu_bar}")
        
        # Memory usage (show total and average)
        mem_total = stats['memory_stats']['current']
        mem_avg = stats['memory_stats']['average']
        mem_bar = self.create_usage_bar(min(mem_avg, 1000) / 10, 30)  # Scale for visualization
        self.stdscr.addstr(4, left_col, f"Mem: {mem_total:7.1f}MB total {mem_bar}")
        
        # Right column - Network and Disk I/O
        right_col = width // 2 + 5
        if right_col < width - 40:  # Only if there's enough space
            # Session totals
            net_total_formatted = self.format_bytes(stats['session_totals']['net_total'])
            disk_total_formatted = self.format_bytes(stats['session_totals']['disk_total'])
            self.stdscr.addstr(1, right_col, f"Session Totals:")
            self.stdscr.addstr(2, right_col, f"  Network: {net_total_formatted}")
            self.stdscr.addstr(3, right_col, f"  Disk I/O: {disk_total_formatted}")
            
            # Current rates
            net_in_rate = self.format_bytes(stats['current_rates']['net_in_rate'])
            net_out_rate = self.format_bytes(stats['current_rates']['net_out_rate'])
            disk_rate = self.format_bytes(stats['current_rates']['disk_rate'])
            self.stdscr.addstr(4, right_col, f"  Current: ↓{net_in_rate} ↑{net_out_rate} ⚡{disk_rate}")
        
        # Additional stats line
        connections = stats['process_stats']['total_connections']
        mcp_count = stats['process_stats']['with_mcp']
        historical_sessions = stats['historical_averages']['sessions']
        
        additional_stats = f"Connections: {connections} | MCP: {mcp_count} | Historical Sessions (7d): {historical_sessions}"
        if len(additional_stats) < width - 4:
            self.stdscr.addstr(5, left_col, additional_stats)
        
        # Column headers with sort indicator
        sort_indicators = {
            'pid': 'PID',
            'cpu': 'CPU%',
            'memory': 'Mem(MB)',
            'tokens': 'Tokens',
            'time': 'Time'
        }
        
        # Build headers with sort indicator - split I/O columns
        headers_parts = [
            ('PID', 7, 'pid'),
            ('Status', 8, None),
            ('CPU%', 6, 'cpu'),
            ('Mem(MB)', 8, 'memory'),
            ('Net↑', 8, 'net_out'),
            ('Net↓', 8, 'net_in'),
            ('NetΣ', 8, 'net_total'),
            ('DiskΣ', 8, 'disk_total'),
            ('Disk∆', 8, 'disk_current'),
            ('Conn', 5, 'connections'),
            ('Time', 8, 'time'),
            ('Working Directory', 0, None)
        ]
        
        header_line = ""
        pos = 0
        for label, width, sort_field in headers_parts:
            if sort_field == self.monitor.sort_key:
                # Add sort indicator
                indicator = '▼' if self.monitor.reverse_sort else '▲'
                if width > 0:
                    display_label = f"{label}{indicator}"
                    header_line += f"{display_label:>{width}} "
                else:
                    header_line += f"{label}{indicator}"
            else:
                if width > 0:
                    header_line += f"{label:>{width}} "
                else:
                    header_line += label
        
        self.stdscr.attron(curses.A_UNDERLINE)
        self.stdscr.addstr(7, 0, header_line[:width-1])  # Moved down to line 7
        self.stdscr.attroff(curses.A_UNDERLINE)
        
    def apply_search_filter(self):
        """Apply search filter to instances"""
        if not self.search_query:
            self.filtered_instances = self.monitor.instances
        else:
            query = self.search_query.lower()
            self.filtered_instances = [
                inst for inst in self.monitor.instances
                if (query in inst.working_dir.lower() or
                    query in inst.command.lower() or
                    query in inst.status.lower() or
                    str(inst.pid) == query)
            ]
        
        # Adjust selected index if needed
        if self.monitor.selected_index >= len(self.filtered_instances):
            self.monitor.selected_index = max(0, len(self.filtered_instances) - 1)
    
    def draw_grouped_instances(self, start_y, visible_lines, width):
        """Draw instances grouped by project"""
        y = start_y
        line_count = 0
        
        # Sort projects by name
        sorted_projects = sorted(self.monitor.project_groups.keys())
        
        for project_idx, project_path in enumerate(sorted_projects):
            if line_count >= visible_lines:
                break
                
            instances = self.monitor.project_groups[project_path]
            project_name = os.path.basename(project_path) or "root"
            
            # Draw project header
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            header = f"▼ {project_name} ({len(instances)} instances)"
            
            # Add aggregate stats for the project
            total_cpu = sum(inst.cpu_percent for inst in instances)
            total_mem = sum(inst.memory_mb for inst in instances)
            header += f" - CPU: {total_cpu:.1f}% Mem: {total_mem:.0f}MB"
            
            self.stdscr.addstr(y, 0, header[:width-1])
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
            y += 1
            line_count += 1
            
            # Draw instances in this project
            for inst_idx, instance in enumerate(instances):
                if line_count >= visible_lines:
                    break
                
                # Indented instance display
                self.draw_instance_row(instance, y, 2, width, False)  # indent by 2
                
                y += 1
                line_count += 1
    
    def draw_instance_row(self, instance, y, indent, width, is_selected):
        """Draw a single instance row"""
        # Color based on status
        if instance.status == 'running':
            color = curses.color_pair(1)  # Green
        elif instance.status == 'waiting':
            color = curses.color_pair(4)  # Cyan - waiting for user
        elif instance.status == 'idle':
            color = curses.color_pair(0)  # Default - minimal activity
        elif instance.status == 'paused':
            color = curses.color_pair(2)  # Yellow
        else:
            color = curses.color_pair(0)
        
        # High resource usage warning
        if instance.cpu_percent > 80 or instance.memory_mb > 1000:
            color = curses.color_pair(3)
        
        # Format the row
        elapsed = datetime.now() - instance.start_time
        elapsed_str = f"{elapsed.seconds//3600:02d}:{(elapsed.seconds//60)%60:02d}:{elapsed.seconds%60:02d}"
        
        # Directory display
        if self.monitor.show_full_path:
            dir_display = instance.working_dir
        else:
            parts = instance.working_dir.split('/')
            if len(parts) > 2:
                dir_display = '/'.join(parts[-2:])
            else:
                dir_display = instance.working_dir
        
        # Format I/O data
        net_out_display = self.format_bytes(instance.net_bytes_sent)
        net_in_display = self.format_bytes(instance.net_bytes_recv)
        net_total_display = self.format_bytes(instance.net_bytes_total)
        disk_total_display = self.format_bytes(instance.disk_total_bytes)
        disk_current_display = self.format_bytes(instance.disk_current_bytes)
        
        # Connection display
        if instance.mcp_connections > 0:
            conn_display = f"{instance.connections_count}M"
        else:
            conn_display = f"{instance.connections_count}"
        
        # Build row
        spacing = " " * indent
        if self.multi_select_mode:
            checkbox = "[×]" if instance.pid in self.selected_instances else "[ ]"
            selection_indicator = "→" if is_selected else " "
            row = f"{spacing}{checkbox}{selection_indicator}{instance.pid:>6} {instance.status:>8} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_out_display:>8} {net_in_display:>8} {net_total_display:>8} {disk_total_display:>8} {disk_current_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
        else:
            if is_selected:
                row = f"{spacing}→ {instance.pid:>6} {instance.status:>8} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_out_display:>8} {net_in_display:>8} {net_total_display:>8} {disk_total_display:>8} {disk_current_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
            else:
                row = f"{spacing}  {instance.pid:>6} {instance.status:>8} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_out_display:>8} {net_in_display:>8} {net_total_display:>8} {disk_total_display:>8} {disk_current_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
        
        if is_selected:
            self.stdscr.attron(curses.color_pair(5))
        
        self.stdscr.attron(color)
        self.stdscr.addstr(y, 0, row[:width-1])
        self.stdscr.attroff(color)
        
        if is_selected:
            self.stdscr.attroff(curses.color_pair(5))
    
    def draw_instances(self):
        """Draw the list of Claude instances"""
        height, width = self.stdscr.getmaxyx()
        start_y = 8  # Start after expanded header
        visible_lines = height - start_y - 3  # Leave room for footer
        
        # Use filtered instances if search is active
        instances_to_show = self.filtered_instances if self.search_mode or self.search_query else self.monitor.instances
        
        if self.monitor.group_by_project and not self.search_query:
            # Grouped display mode
            self.draw_grouped_instances(start_y, visible_lines, width)
        else:
            # Normal flat display
            for idx, instance in enumerate(instances_to_show[:visible_lines]):
                y = start_y + idx
                is_selected = idx == self.monitor.selected_index
                self.draw_instance_row(instance, y, 0, width, is_selected)
    
    def draw_footer(self):
        """Draw the footer with commands"""
        height, width = self.stdscr.getmaxyx()
        
        # Search bar if in search mode
        if self.search_mode:
            self.stdscr.attron(curses.color_pair(4))
            search_prompt = f"Search: {self.search_query}_"
            self.stdscr.addstr(height-3, 2, search_prompt[:width-4])
            self.stdscr.attroff(curses.color_pair(4))
        # Error message if any
        elif self.error_message:
            self.stdscr.attron(curses.color_pair(3))
            self.stdscr.addstr(height-3, 2, self.error_message[:width-4])
            self.stdscr.attroff(curses.color_pair(3))
        
        # Show filtered count if search is active
        if self.search_query and not self.search_mode:
            filter_info = f"[Filtered: {len(self.filtered_instances)}/{len(self.monitor.instances)}]"
            self.stdscr.addstr(height-3, 2, filter_info)
        
        # Show multi-select info
        if self.multi_select_mode:
            select_info = f"[Multi-select: {len(self.selected_instances)} selected]"
            self.stdscr.addstr(height-2, 2, select_info)
        
        # Commands with database indicator
        db_status = " [DB]" if self.monitor.enable_database else ""
        if self.multi_select_mode:
            commands = f"Space:Select  a:All  n:None  p:Pause  K:Kill  ESC:Exit  ↑↓:Navigate{db_status}"
        else:
            commands = f"q:Quit  /:Search  m:Multi  g:Group  p:Pause  K:Kill  s:Sort  f:Path  h:Help{db_status}"
        self.stdscr.addstr(height-1, 2, commands[:width-4])
    
    def draw_help(self):
        """Draw help overlay"""
        height, width = self.stdscr.getmaxyx()
        help_text = [
            "Claude-Top Help",
            "",
            "Navigation:",
            "  ↑/↓ or j/k  - Move selection up/down",
            "  Home/End    - Go to first/last item",
            "",
            "Search & Filter:",
            "  /           - Enter search mode",
            "  ESC         - Clear search/Exit search mode",
            "  Search by: PID, status, command, or directory",
            "",
            "Multi-Select Mode:",
            "  m           - Enter multi-select mode",
            "  Space       - Toggle selection",
            "  a           - Select all",
            "  n           - Select none",
            "  p           - Pause/Resume selected",
            "  K           - Kill selected (with confirmation)",
            "  ESC         - Exit multi-select mode",
            "",
            "Actions:",
            "  p           - Pause/Resume selected instance",
            "  K           - Kill selected instance (with confirmation)",
            "  f           - Toggle full/short directory path",
            "  g           - Group by project/workspace",
            "",
            "Sorting:",
            "  s           - Cycle: PID→CPU→Mem→Net↑→Net↓→NetΣ→DiskΣ→Disk∆→Conn→Time",
            "  r           - Reverse sort order",
            "",
            "Display Columns:",
            "  Net↑        - Network bytes sent (outbound)",
            "  Net↓        - Network bytes received (inbound)", 
            "  NetΣ        - Total network I/O (cumulative)",
            "  DiskΣ       - Total disk I/O (cumulative)",
            "  Disk∆       - Current disk activity (this cycle)",
            "  Conn        - Network connections (M = MCP detected)",
            "",
            "Controls:",
            "  h           - Toggle this help",
            "  d           - Show database statistics (if enabled)",
            "  q or Esc    - Quit",
            "",
            "Press any key to close help..."
        ]
        
        # Calculate box dimensions
        box_height = len(help_text) + 4
        box_width = max(len(line) for line in help_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw box
        self.stdscr.attron(curses.color_pair(4))
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw help text
        for i, line in enumerate(help_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(4))
    
    def handle_input(self):
        """Handle keyboard input"""
        key = self.stdscr.getch()
        
        if self.show_help:
            # Wait for any key press to close help
            if key != -1:
                self.show_help = False
            return True
        
        # Handle search mode input
        if self.search_mode:
            if key == 27:  # ESC - exit search
                self.search_mode = False
                if not self.search_query:
                    self.filtered_instances = self.monitor.instances
            elif key == ord('\n'):  # Enter - confirm search
                self.search_mode = False
                self.apply_search_filter()
            elif key == curses.KEY_BACKSPACE or key == 127:
                if self.search_query:
                    self.search_query = self.search_query[:-1]
                    self.apply_search_filter()
            elif 32 <= key <= 126:  # Printable characters
                self.search_query += chr(key)
                self.apply_search_filter()
            return True
        
        # Handle multi-select mode
        if self.multi_select_mode:
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            
            if key == 27:  # ESC - exit multi-select
                self.multi_select_mode = False
                self.selected_instances.clear()
            elif key == ord(' '):  # Space - toggle selection
                if instances and self.monitor.selected_index < len(instances):
                    pid = instances[self.monitor.selected_index].pid
                    if pid in self.selected_instances:
                        self.selected_instances.remove(pid)
                    else:
                        self.selected_instances.add(pid)
            elif key == ord('a'):  # Select all
                self.selected_instances = {inst.pid for inst in instances}
            elif key == ord('n'):  # Select none
                self.selected_instances.clear()
            elif key == ord('p'):  # Batch pause/resume
                if self.selected_instances:
                    for pid in self.selected_instances:
                        self.monitor.pause_resume_process(pid)
                    self.selected_instances.clear()
                    self.multi_select_mode = False
            elif key == ord('K'):  # Batch kill
                if self.selected_instances:
                    if self.show_batch_kill_confirmation():
                        self.selected_instances.clear()
                        self.multi_select_mode = False
            # Navigation in multi-select mode
            elif key == curses.KEY_UP or key == ord('k'):
                if self.monitor.selected_index > 0:
                    self.monitor.selected_index -= 1
            elif key == curses.KEY_DOWN or key == ord('j'):
                if self.monitor.selected_index < len(instances) - 1:
                    self.monitor.selected_index += 1
            return True
        
        # Normal mode
        if key == ord('q'):  # q to quit
            return False
        elif key == 27:  # ESC - clear search
            if self.search_query:
                self.search_query = ""
                self.filtered_instances = self.monitor.instances
                self.apply_search_filter()
            else:
                return False
        elif key == ord('/'):  # Enter search mode
            self.search_mode = True
            self.search_query = ""
        elif key == ord('m'):  # Enter multi-select mode
            self.multi_select_mode = True
            self.selected_instances.clear()
        elif key == ord('g'):  # Toggle group by project
            self.monitor.group_by_project = not self.monitor.group_by_project
            if self.monitor.group_by_project:
                self.monitor.group_instances_by_project()
        elif key == ord('h'):
            self.show_help = True
        elif key == curses.KEY_UP or key == ord('k'):
            if self.monitor.selected_index > 0:
                self.monitor.selected_index -= 1
        elif key == curses.KEY_DOWN or key == ord('j'):
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if self.monitor.selected_index < len(instances) - 1:
                self.monitor.selected_index += 1
        elif key == ord('p'):
            # Pause/Resume selected instance
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if instances and self.monitor.selected_index < len(instances):
                instance = instances[self.monitor.selected_index]
                error = self.monitor.pause_resume_process(instance.pid)
                if error:
                    self.error_message = error
                else:
                    self.error_message = ""
        elif key == ord('K'):  # Capital K for kill (to avoid accidental kills)
            # Kill selected instance with confirmation
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if instances and self.monitor.selected_index < len(instances):
                instance = instances[self.monitor.selected_index]
                choice = self.show_kill_confirmation(instance)
                
                if choice == 'graceful':
                    error, message = self.monitor.kill_process(instance.pid, force=False)
                    if error:
                        self.error_message = error
                    else:
                        self.error_message = message or "Process terminated"
                elif choice == 'force':
                    error, message = self.monitor.kill_process(instance.pid, force=True)
                    if error:
                        self.error_message = error
                    else:
                        self.error_message = message or "Process killed"
                # If choice is None (cancel), do nothing
        elif key == ord('s'):
            # Cycle through sort options - split I/O columns
            sort_options = ['pid', 'cpu', 'memory', 'net_out', 'net_in', 'net_total', 'disk_total', 'disk_current', 'connections', 'time']
            current_idx = sort_options.index(self.monitor.sort_key)
            self.monitor.sort_key = sort_options[(current_idx + 1) % len(sort_options)]
            self.monitor.sort_instances()
        elif key == ord('r'):
            # Reverse sort order
            self.monitor.reverse_sort = not self.monitor.reverse_sort
        
        elif key == ord('f') or key == ord('F'):
            # Toggle full path display
            self.monitor.show_full_path = not self.monitor.show_full_path
            self.monitor.sort_instances()
        elif key == ord('d') or key == ord('D'):
            # Show database statistics
            if self.monitor.enable_database and self.monitor.db:
                self.show_database_stats()
            else:
                self.error_message = "Database tracking not enabled"
        
        return True
    
    def show_database_stats(self):
        """Show database statistics overlay"""
        height, width = self.stdscr.getmaxyx()
        
        try:
            # Get analytics
            analytics = ClaudeAnalytics(self.monitor.db.db_path)
            reports = analytics.generate_usage_report(7)
            active_sessions = self.monitor.db.get_active_sessions()
            
            stats_text = [
                "Database Statistics (Last 7 Days)",
                "",
                f"Active Sessions: {len(active_sessions)}",
                f"Total Projects: {len(reports)}",
                "",
                "Top Projects by Runtime:",
            ]
            
            for i, report in enumerate(reports[:5], 1):
                stats_text.append(f"  {i}. {report.project_name}: {report.total_runtime_hours:.1f}h")
            
            if reports:
                stats_text.extend([
                    "",
                    "Current Session Summary:",
                    f"  Avg CPU: {sum(r.avg_cpu_percent for r in reports)/len(reports):.1f}%",
                    f"  Avg Memory: {sum(r.avg_memory_mb for r in reports)/len(reports):.1f}MB",
                    f"  Total Network: {sum(r.total_network_bytes for r in reports)}B",
                    f"  Total Disk: {sum(r.total_disk_bytes for r in reports)}B"
                ])
            
            stats_text.extend([
                "",
                "Press any key to close..."
            ])
        except Exception as e:
            stats_text = [
                "Database Statistics",
                "",
                f"Error loading statistics: {str(e)}",
                "",
                "Press any key to close..."
            ]
        
        # Calculate box dimensions
        box_height = len(stats_text) + 4
        box_width = max(len(line) for line in stats_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw box
        self.stdscr.attron(curses.color_pair(4))
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw stats text
        for i, line in enumerate(stats_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(4))
        
        self.stdscr.refresh()
        
        # Wait for keypress
        self.stdscr.getch()

    def show_kill_confirmation(self, instance):
        """Show kill confirmation dialog with three options"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_text = [
            f"Kill Process {instance.pid}?",
            "",
            f"Process: {instance.working_dir.split('/')[-1]}",
            f"Command: {instance.command[:50]}...",
            f"Status: {instance.status}",
            f"CPU: {instance.cpu_percent:.1f}%",
            f"Memory: {instance.memory_mb:.1f}MB",
            "",
            "Choose action:",
            "",
            "  [C] Cancel",
            "  [G] Kill Gracefully (SIGTERM)",
            "  [F] Kill Now (SIGKILL)",
            "",
            "Press C, G, or F..."
        ]
        
        # Calculate dialog dimensions
        box_height = len(dialog_text) + 4
        box_width = max(len(line) for line in dialog_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog box background
        self.stdscr.attron(curses.color_pair(3))  # Red/warning color
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw border
        for y in range(box_height):
            if y == 0 or y == box_height - 1:
                # Top and bottom border
                self.stdscr.addstr(start_y + y, start_x, "─" * box_width)
            else:
                # Side borders
                self.stdscr.addstr(start_y + y, start_x, "│")
                self.stdscr.addstr(start_y + y, start_x + box_width - 1, "│")
        
        # Corner characters
        self.stdscr.addstr(start_y, start_x, "┌")
        self.stdscr.addstr(start_y, start_x + box_width - 1, "┐")
        self.stdscr.addstr(start_y + box_height - 1, start_x, "└")
        self.stdscr.addstr(start_y + box_height - 1, start_x + box_width - 1, "┘")
        
        # Draw dialog text
        for i, line in enumerate(dialog_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        
        self.stdscr.attroff(curses.color_pair(3))
        self.stdscr.refresh()
        
        # Wait for user choice
        while True:
            key = self.stdscr.getch()
            if key == ord('c') or key == ord('C') or key == 27:  # Cancel or ESC
                return None
            elif key == ord('g') or key == ord('G'):
                return 'graceful'
            elif key == ord('f') or key == ord('F'):
                return 'force'
    
    def show_batch_kill_confirmation(self):
        """Show batch kill confirmation dialog"""
        height, width = self.stdscr.getmaxyx()
        
        instances = self.filtered_instances if self.search_query else self.monitor.instances
        selected = [inst for inst in instances if inst.pid in self.selected_instances]
        
        dialog_text = [
            f"Kill {len(selected)} Processes?",
            "",
            "Selected processes:",
        ]
        
        # Show first few selected processes
        for inst in selected[:5]:
            dialog_text.append(f"  PID {inst.pid}: {inst.working_dir.split('/')[-1]}")
        
        if len(selected) > 5:
            dialog_text.append(f"  ... and {len(selected) - 5} more")
        
        dialog_text.extend([
            "",
            "Choose action:",
            "",
            "  [C] Cancel",
            "  [G] Kill All Gracefully (SIGTERM)",
            "  [F] Kill All Now (SIGKILL)",
            "",
            "Press C, G, or F..."
        ])
        
        # Calculate dialog dimensions
        box_height = len(dialog_text) + 4
        box_width = max(len(line) for line in dialog_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog box
        self.stdscr.attron(curses.color_pair(3))  # Red/warning color
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw border
        for y in range(box_height):
            if y == 0 or y == box_height - 1:
                self.stdscr.addstr(start_y + y, start_x, "─" * box_width)
            else:
                self.stdscr.addstr(start_y + y, start_x, "│")
                self.stdscr.addstr(start_y + y, start_x + box_width - 1, "│")
        
        # Corner characters
        self.stdscr.addstr(start_y, start_x, "┌")
        self.stdscr.addstr(start_y, start_x + box_width - 1, "┐")
        self.stdscr.addstr(start_y + box_height - 1, start_x, "└")
        self.stdscr.addstr(start_y + box_height - 1, start_x + box_width - 1, "┘")
        
        # Draw dialog text
        for i, line in enumerate(dialog_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        
        self.stdscr.attroff(curses.color_pair(3))
        self.stdscr.refresh()
        
        # Wait for user choice
        while True:
            key = self.stdscr.getch()
            if key == ord('c') or key == ord('C') or key == 27:  # Cancel or ESC
                return False
            elif key == ord('g') or key == ord('G'):
                # Kill all gracefully
                for pid in self.selected_instances:
                    self.monitor.kill_process(pid, force=False)
                self.error_message = f"Terminated {len(self.selected_instances)} processes gracefully"
                return True
            elif key == ord('f') or key == ord('F'):
                # Kill all forcefully
                for pid in self.selected_instances:
                    self.monitor.kill_process(pid, force=True)
                self.error_message = f"Killed {len(self.selected_instances)} processes forcefully"
                return True
    
    def run(self):
        """Main UI loop"""
        self.stdscr.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor
        
        last_update = 0
        running = True
        
        while running:
            current_time = time.time()
            
            # Update data periodically
            if current_time - last_update > self.monitor.update_interval:
                self.monitor.instances = self.monitor.find_claude_processes()
                self.monitor.sort_instances()
                
                # Update grouping if enabled
                if self.monitor.group_by_project:
                    self.monitor.group_instances_by_project()
                
                # Apply search filter if active
                if self.search_query:
                    self.apply_search_filter()
                else:
                    self.filtered_instances = self.monitor.instances
                
                last_update = current_time
                
                # Clean up old CPU histories
                current_pids = {inst.pid for inst in self.monitor.instances}
                self.monitor.cpu_histories = {pid: hist for pid, hist in self.monitor.cpu_histories.items() if pid in current_pids}
                
                # Clean up selected instances for batch operations
                self.selected_instances = {pid for pid in self.selected_instances if pid in current_pids}
                
                # Adjust selected index if needed
                instances = self.filtered_instances if self.search_query else self.monitor.instances
                if self.monitor.selected_index >= len(instances):
                    self.monitor.selected_index = max(0, len(instances) - 1)
            
            # Clear and redraw
            self.stdscr.clear()
            
            if self.show_help:
                self.draw_help()
            else:
                self.draw_header()
                self.draw_instances()
                self.draw_footer()
            
            self.stdscr.refresh()
            
            # Handle input
            running = self.handle_input()
            
            # Small delay to prevent high CPU usage
            time.sleep(0.05)

def main(stdscr):
    """Main entry point"""
    # Access global args
    enable_db = not global_args.no_database if 'global_args' in globals() else True
    db_path = global_args.db_path if 'global_args' in globals() else "claude_tracking.db"
    
    # Create monitor with database options
    monitor = ClaudeMonitor(enable_database=enable_db)
    if enable_db and monitor.enable_database and monitor.db:
        monitor.db.db_path = db_path
    
    ui = ClaudeTopUI(stdscr)
    ui.monitor = monitor  # Replace default monitor
    
    try:
        ui.run()
    finally:
        # Graceful shutdown - end database sessions
        if ui.monitor.enable_database and ui.monitor.db:
            for pid, session_id in ui.monitor.active_sessions.items():
                ui.monitor.db.end_session(session_id)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Monitor Claude CLI instances with SQLite tracking")
    parser.add_argument('--interval', type=float, default=1.0, help="Update interval in seconds")
    parser.add_argument('--no-database', action='store_true', help="Disable database tracking")
    parser.add_argument('--db-path', default="claude_tracking.db", help="Database file path")
    args = parser.parse_args()
    
    # Store args globally for access in main
    global_args = args
    
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
