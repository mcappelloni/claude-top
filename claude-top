#!/usr/bin/env python3
"""
claude-top: A terminal-based monitoring tool for Claude CLI instances
"""

import curses
import json
import os
import psutil
import signal
import sys
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Dict
from collections import deque
import subprocess
import argparse

# Import database tracking components
try:
    from database_schema import ClaudeDatabase
    from process_tree import ProcessTreeTracker
    from analytics import ClaudeAnalytics
    from historical_analytics import HistoricalAnalytics
    from data_export import DataExporter
    from productivity_metrics import ProductivityAnalyzer
    from process_management import ProcessManager
    from realtime_dashboard import RealTimeDashboard, RealTimeMetrics
    from visual_indicators import VisualIndicators, IndicatorStyle
    from performance_optimizer import PerformanceOptimizer
    DATABASE_AVAILABLE = True
except ImportError:
    DATABASE_AVAILABLE = False

@dataclass
class ClaudeInstance:
    pid: int
    working_dir: str
    task: str
    context_length: int
    tokens_used: int
    start_time: datetime
    status: str  # 'running', 'idle', 'waiting', 'paused'
    cpu_percent: float
    memory_mb: float
    command: str
    cpu_history: deque = field(default_factory=lambda: deque(maxlen=5))
    net_bytes_sent: int = 0
    net_bytes_recv: int = 0
    net_bytes_total: int = 0
    disk_total_bytes: int = 0
    disk_current_bytes: int = 0  # Current cycle activity
    connections_count: int = 0
    mcp_connections: int = 0

class ClaudeMonitor:
    def __init__(self, enable_database: bool = True):
        self.instances: List[ClaudeInstance] = []
        self.selected_index = 0
        self.paused_pids = set()
        self.update_interval = 1.0
        self.sort_key = 'pid'
        self.reverse_sort = False
        self.show_full_path = False
        self.cpu_histories = {}  # Track CPU history for each PID
        self.group_by_project = False
        self.project_groups = {}  # project_path -> list of instances
        
        # Alert configuration
        self.alerts_enabled = True
        self.cpu_threshold = 80.0  # Alert when CPU > 80%
        self.memory_threshold = 1000.0  # Alert when memory > 1GB
        self.alert_history = {}  # pid -> {'cpu': timestamp, 'memory': timestamp}
        self.alert_cooldown = 60  # Don't repeat same alert for 60 seconds
        
        # Database tracking
        self.enable_database = enable_database and DATABASE_AVAILABLE
        self.db = None
        self.tree_tracker = None
        self.active_sessions = {}  # pid -> session_id
        self.project_cache = {}    # working_dir -> project_id
        
        if self.enable_database:
            try:
                self.db = ClaudeDatabase()
                self.tree_tracker = ProcessTreeTracker()
            except Exception as e:
                print(f"Warning: Database initialization failed: {e}")
                self.enable_database = False
        
    def find_claude_processes(self):
        """Find all Claude CLI processes running on the system"""
        claude_processes = []
        current_pid = os.getpid()  # Get claude-top's own PID
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cwd', 'create_time', 'cpu_percent', 'memory_info']):
            try:
                # Skip our own process (claude-top)
                if proc.info['pid'] == current_pid:
                    continue
                
                # Check if this is a Claude CLI process
                cmdline = proc.info.get('cmdline', [])
                if not cmdline:
                    continue
                
                # More specific Claude CLI detection
                # Look for actual claude command as the first argument or 'claude' executable
                is_claude_cli = False
                
                # Check if first argument is 'claude' (the CLI command)
                if cmdline[0] == 'claude' or cmdline[0].endswith('/claude'):
                    is_claude_cli = True
                
                # Check for common patterns of Claude CLI execution
                elif len(cmdline) >= 2:
                    # Check for: python/python3 claude, npm/node claude, etc.
                    if cmdline[1] == 'claude' or cmdline[1].endswith('/claude'):
                        is_claude_cli = True
                    # Check for: npm view @anthropic-ai/claude-code
                    elif 'npm' in cmdline[0] and len(cmdline) > 2 and '@anthropic-ai/claude-code' in cmdline:
                        is_claude_cli = True
                    # Check for: npx claude
                    elif cmdline[0].endswith('npx') and cmdline[1] == 'claude':
                        is_claude_cli = True
                
                # Additional check for Claude CLI installed via npm/yarn globally
                # e.g., /usr/local/bin/node /usr/local/lib/node_modules/@anthropic-ai/claude-code/bin/claude
                if not is_claude_cli and len(cmdline) >= 2:
                    if '@anthropic-ai/claude-code' in cmdline[1] and cmdline[1].endswith('/claude'):
                        is_claude_cli = True
                
                if not is_claude_cli:
                    continue
                
                cmdline_str = ' '.join(cmdline)
                
                # Skip claude-top itself (additional check by command)
                if 'claude-top' in cmdline_str or './claude-top' in cmdline_str:
                    continue
                
                # Extract relevant information
                instance = self.parse_claude_process(proc)
                if instance:
                    claude_processes.append(instance)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        # Database tracking
        if self.enable_database and self.db:
            self.track_processes_in_database(claude_processes)
                
        return claude_processes
    
    def track_processes_in_database(self, instances: List[ClaudeInstance]):
        """Track processes in database"""
        try:
            current_pids = {inst.pid for inst in instances}
            
            # End sessions for processes that are no longer running
            ended_pids = set(self.active_sessions.keys()) - current_pids
            for pid in ended_pids:
                session_id = self.active_sessions[pid]
                self.db.end_session(session_id)
                del self.active_sessions[pid]
            
            # Start sessions for new processes and record metrics for all
            for instance in instances:
                if instance.pid not in self.active_sessions:
                    # Start new session
                    project_id = self.get_or_create_project(instance.working_dir)
                    session_id = self.db.start_session(
                        instance.pid, 
                        project_id, 
                        instance.command
                    )
                    self.active_sessions[instance.pid] = session_id
                
                # Record current metrics
                session_id = self.active_sessions[instance.pid]
                metrics = {
                    'cpu_percent': instance.cpu_percent,
                    'memory_mb': instance.memory_mb,
                    'net_bytes_sent': instance.net_bytes_sent,
                    'net_bytes_recv': instance.net_bytes_recv,
                    'net_bytes_total': instance.net_bytes_total,
                    'disk_total_bytes': instance.disk_total_bytes,
                    'disk_current_bytes': instance.disk_current_bytes,
                    'connections_count': instance.connections_count,
                    'mcp_connections': instance.mcp_connections,
                    'status': instance.status
                }
                self.db.record_metrics(session_id, metrics)
        except Exception as e:
            # Don't let database errors break the monitoring
            pass
    
    def get_or_create_project(self, working_dir: str) -> int:
        """Get or create project with caching"""
        if working_dir in self.project_cache:
            return self.project_cache[working_dir]
        
        project_id = self.db.get_or_create_project(working_dir)
        self.project_cache[working_dir] = project_id
        return project_id
    
    def calculate_summary_stats(self, instances: List[ClaudeInstance]) -> Dict[str, any]:
        """Calculate comprehensive summary statistics for all Claude instances"""
        if not instances:
            return {
                'session_totals': {'net_in': 0, 'net_out': 0, 'net_total': 0, 'disk_total': 0, 'disk_current': 0},
                'current_rates': {'net_in_rate': 0, 'net_out_rate': 0, 'disk_rate': 0},
                'cpu_stats': {'current': 0, 'average': 0, 'count_running': 0, 'count_idle': 0, 'count_waiting': 0},
                'memory_stats': {'current': 0, 'average': 0, 'peak': 0},
                'process_stats': {'total': 0, 'with_mcp': 0, 'total_connections': 0},
                'historical_averages': {'cpu': 0, 'memory': 0, 'sessions': 0}
            }
        
        # Session totals (cumulative across all processes)
        session_totals = {
            'net_in': sum(inst.net_bytes_recv for inst in instances),
            'net_out': sum(inst.net_bytes_sent for inst in instances), 
            'net_total': sum(inst.net_bytes_total for inst in instances),
            'disk_total': sum(inst.disk_total_bytes for inst in instances),
            'disk_current': sum(inst.disk_current_bytes for inst in instances)
        }
        
        # Current rates (current cycle activity)
        current_rates = {
            'net_in_rate': session_totals['net_in'],  # Current cycle in
            'net_out_rate': session_totals['net_out'], # Current cycle out
            'disk_rate': session_totals['disk_current']  # Current cycle disk
        }
        
        # CPU statistics
        cpu_values = [inst.cpu_percent for inst in instances]
        cpu_stats = {
            'current': sum(cpu_values),
            'average': sum(cpu_values) / len(cpu_values) if cpu_values else 0,
            'count_running': sum(1 for inst in instances if inst.status == 'running'),
            'count_idle': sum(1 for inst in instances if inst.status == 'idle'),
            'count_waiting': sum(1 for inst in instances if inst.status == 'waiting'),
            'count_paused': sum(1 for inst in instances if inst.status == 'paused')
        }
        
        # Memory statistics
        memory_values = [inst.memory_mb for inst in instances]
        memory_stats = {
            'current': sum(memory_values),
            'average': sum(memory_values) / len(memory_values) if memory_values else 0,
            'peak': max(memory_values) if memory_values else 0
        }
        
        # Process statistics
        process_stats = {
            'total': len(instances),
            'with_mcp': sum(1 for inst in instances if inst.mcp_connections > 0),
            'total_connections': sum(inst.connections_count for inst in instances)
        }
        
        # Historical averages from database
        historical_averages = {'cpu': 0, 'memory': 0, 'sessions': 0}
        if self.enable_database and self.db:
            try:
                from analytics import ClaudeAnalytics
                analytics = ClaudeAnalytics(self.db.db_path)
                reports = analytics.generate_usage_report(7)  # Last 7 days
                if reports:
                    historical_averages = {
                        'cpu': sum(r.avg_cpu_percent for r in reports) / len(reports),
                        'memory': sum(r.avg_memory_mb for r in reports) / len(reports),
                        'sessions': sum(r.session_count for r in reports)
                    }
            except:
                pass
        
        return {
            'session_totals': session_totals,
            'current_rates': current_rates,
            'cpu_stats': cpu_stats,
            'memory_stats': memory_stats,
            'process_stats': process_stats,
            'historical_averages': historical_averages
        }
    
    def parse_claude_process(self, proc) -> Optional[ClaudeInstance]:
        """Parse process information to create ClaudeInstance"""
        try:
            info = proc.info
            pid = info['pid']
            # Get working directory - try multiple methods
            cwd = info.get('cwd', None)
            if not cwd or cwd == '/':
                try:
                    # Try to get cwd directly from process
                    cwd = proc.cwd()
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    cwd = 'Unknown'
            
            cmdline = ' '.join(info.get('cmdline', []))
            
            # For now, we'll use a placeholder for task
            task = "Active Session"
            
            # Token/context information not available from external sources
            context_length, tokens_used = 0, 0
            
            # Initialize CPU history for new processes
            if pid not in self.cpu_histories:
                self.cpu_histories[pid] = deque(maxlen=5)
            
            # Update CPU history
            current_cpu = info.get('cpu_percent', 0.0)
            self.cpu_histories[pid].append(current_cpu)
            
            # Determine status based on CPU usage patterns
            status = self.determine_process_status(pid, proc)
            
            # Get network and disk I/O statistics
            net_io, disk_io, connections_info = self.get_io_stats(proc)
            
            return ClaudeInstance(
                pid=pid,
                working_dir=cwd,
                task=task,
                context_length=context_length,
                tokens_used=tokens_used,
                start_time=datetime.fromtimestamp(info['create_time']),
                status=status,
                cpu_percent=info.get('cpu_percent', 0.0),
                memory_mb=info.get('memory_info').rss / 1024 / 1024 if info.get('memory_info') else 0,
                command=cmdline,
                cpu_history=self.cpu_histories[pid].copy(),
                net_bytes_sent=net_io['bytes_sent'],
                net_bytes_recv=net_io['bytes_recv'],
                net_bytes_total=net_io['bytes_total'],
                disk_total_bytes=disk_io['total_bytes'],
                disk_current_bytes=disk_io['current_bytes'],
                connections_count=connections_info['total_connections'],
                mcp_connections=connections_info['mcp_connections']
            )
        except Exception:
            return None
    
    def extract_task_from_cmdline(self, cmdline: str) -> str:
        """Extract task description from command line"""
        # This is a simplified extraction - in reality, you'd parse Claude's specific format
        if '--task' in cmdline:
            parts = cmdline.split('--task')
            if len(parts) > 1:
                return parts[1].split()[0].strip('"\'')
        elif 'claude' in cmdline:
            # Try to extract any quoted strings as potential tasks
            import re
            quotes = re.findall(r'"([^"]*)"', cmdline)
            if quotes:
                return quotes[0][:50] + '...' if len(quotes[0]) > 50 else quotes[0]
        return "Unknown Task"
    
    def get_claude_metrics(self, pid: int, working_dir: str) -> tuple:
        """Token/context information not available from external sources"""
        # Claude CLI does not expose token/context data in accessible files
        # This information is only available internally via /cost command
        return 0, 0
    
    def get_io_stats(self, proc):
        """Get network I/O, disk I/O, and connection statistics for a process"""
        try:
            pid = proc.pid
            
            # Initialize I/O tracker if not exists
            if not hasattr(self, 'io_tracker'):
                self.io_tracker = {}
            if not hasattr(self, 'io_totals'):
                self.io_totals = {}
            
            # Get current activity indicators
            current_indicators = self.get_activity_indicators(proc)
            
            # Calculate I/O estimates based on activity changes
            if pid in self.io_tracker:
                prev_indicators = self.io_tracker[pid]
                
                # Memory delta often indicates I/O activity
                memory_delta = current_indicators.get('memory_usage', 0) - prev_indicators.get('memory_usage', 0)
                files_delta = current_indicators.get('open_files', 0) - prev_indicators.get('open_files', 0)
                
                # Estimate current cycle disk I/O
                estimated_write = max(0, memory_delta // 10)  # Memory growth -> writes
                estimated_read = abs(files_delta) * 1024  # File activity -> reads
                current_disk_io = estimated_write + estimated_read
                
                # Network estimation based on connection activity and CPU
                conn_count = current_indicators.get('network_connections', 0)
                cpu_factor = max(1, current_indicators.get('cpu_percent', 0) / 10)  # CPU activity affects network
                base_net_activity = conn_count * 1024 * cpu_factor  # More sophisticated estimate
                
                current_net_sent = int(base_net_activity * 0.6)  # Assume more outbound (requests)
                current_net_recv = int(base_net_activity * 0.4)  # Less inbound (responses)
                
                # Update totals
                if pid not in self.io_totals:
                    self.io_totals[pid] = {
                        'total_net_sent': 0, 'total_net_recv': 0, 'total_disk': 0
                    }
                
                self.io_totals[pid]['total_net_sent'] += current_net_sent
                self.io_totals[pid]['total_net_recv'] += current_net_recv
                self.io_totals[pid]['total_disk'] += current_disk_io
                
                net_stats = {
                    'bytes_sent': current_net_sent,
                    'bytes_recv': current_net_recv,
                    'bytes_total': self.io_totals[pid]['total_net_sent'] + self.io_totals[pid]['total_net_recv']
                }
                
                disk_stats = {
                    'total_bytes': self.io_totals[pid]['total_disk'],
                    'current_bytes': current_disk_io
                }
            else:
                # First time seeing this process
                net_stats = {'bytes_sent': 0, 'bytes_recv': 0, 'bytes_total': 0}
                disk_stats = {'total_bytes': 0, 'current_bytes': 0}
                if pid not in self.io_totals:
                    self.io_totals[pid] = {
                        'total_net_sent': 0, 'total_net_recv': 0, 'total_disk': 0
                    }
            
            # Store current indicators for next comparison
            self.io_tracker[pid] = current_indicators
            
            # Connection analysis
            connections_info = {
                'total_connections': current_indicators.get('network_connections', 0),
                'mcp_connections': self.detect_mcp_connections(proc)
            }
            
            return net_stats, disk_stats, connections_info
            
        except Exception:
            # Return default values on any error
            return ({'bytes_sent': 0, 'bytes_recv': 0, 'bytes_total': 0}, 
                   {'total_bytes': 0, 'current_bytes': 0},
                   {'total_connections': 0, 'mcp_connections': 0})
    
    def get_activity_indicators(self, proc):
        """Get activity indicators for a process"""
        indicators = {
            'memory_usage': 0,
            'open_files': 0,
            'threads': 0,
            'network_connections': 0,
            'cpu_percent': 0
        }
        
        try:
            # Memory usage
            memory_info = proc.memory_info()
            indicators['memory_usage'] = memory_info.rss
            
            # CPU usage
            indicators['cpu_percent'] = proc.cpu_percent()
            
            # Thread count
            indicators['threads'] = proc.num_threads()
            
            # Open files count
            try:
                open_files = proc.open_files()
                indicators['open_files'] = len(open_files)
            except psutil.AccessDenied:
                pass
            
            # Network connections
            try:
                connections = proc.net_connections()
                indicators['network_connections'] = len(connections)
            except psutil.AccessDenied:
                pass
                
        except psutil.NoSuchProcess:
            pass
        
        return indicators
    
    def detect_mcp_connections(self, proc):
        """Detect potential MCP connections"""
        try:
            connections = proc.net_connections()
            mcp_count = 0
            
            for conn in connections:
                if conn.status == 'ESTABLISHED':
                    # Heuristic for MCP: WebSocket-like ports or specific patterns
                    if (conn.raddr and conn.raddr.port in [8000, 8080, 3000, 9000] or
                        (conn.laddr and conn.laddr.port > 8000)):
                        mcp_count += 1
            
            return mcp_count
        except (psutil.AccessDenied, AttributeError):
            return 0
    
    def pause_resume_process(self, pid: int):
        """Pause or resume a process"""
        try:
            if pid in self.paused_pids:
                os.kill(pid, signal.SIGCONT)
                self.paused_pids.remove(pid)
            else:
                os.kill(pid, signal.SIGSTOP)
                self.paused_pids.add(pid)
        except Exception as e:
            return f"Error: {str(e)}"
        return None

    def kill_process(self, pid: int, force=False):
        """Kill a process gracefully (SIGTERM) or forcefully (SIGKILL)"""
        try:
            proc = psutil.Process(pid)
            
            if force:
                # Force kill with SIGKILL
                proc.kill()
                return None, "Process killed forcefully (SIGKILL)"
            else:
                # Graceful termination with SIGTERM
                proc.terminate()
                return None, "Process terminated gracefully (SIGTERM)"
                
        except psutil.NoSuchProcess:
            return f"Process {pid} no longer exists", None
        except psutil.AccessDenied:
            return f"Access denied to process {pid}", None
        except Exception as e:
            return f"Error killing process {pid}: {str(e)}", None
    
    def determine_process_status(self, pid, proc):
        """Determine process status based on CPU usage patterns
        
        States:
        - running: Actively processing (>5% CPU)
        - waiting: In conversation, waiting for user input (<0.5% CPU, recent activity)
        - idle: Between sessions, waiting for new instructions (<0.5% CPU, no recent activity)
        - paused: Manually paused or system stopped
        """
        # Check if manually paused
        if pid in self.paused_pids:
            return 'paused'
        
        # Check system status
        sys_status = proc.status()
        if sys_status == 'stopped':
            return 'paused'
        
        # Analyze CPU history
        cpu_samples = list(self.cpu_histories[pid])
        if len(cpu_samples) >= 3:
            avg_cpu = sum(cpu_samples) / len(cpu_samples)
            max_cpu = max(cpu_samples)
            recent_cpu = cpu_samples[-1] if cpu_samples else 0
            
            # Check patterns in CPU history
            recent_samples = cpu_samples[-3:] if len(cpu_samples) >= 3 else cpu_samples
            recent_avg = sum(recent_samples) / len(recent_samples) if recent_samples else 0
            
            # Look for transition from active to idle (indicates waiting)
            had_activity = any(sample > 3.0 for sample in cpu_samples[:-2]) if len(cpu_samples) > 2 else False
            now_idle = recent_avg < 0.5
            
            if avg_cpu > 5.0:
                return 'running'  # Actively processing
            elif recent_avg < 0.5:
                # Very low recent CPU
                if had_activity and max_cpu > 3.0:
                    # Had significant activity before becoming idle - waiting for input
                    return 'waiting'
                elif recent_cpu > 0.2 or any(s > 0.5 for s in recent_samples):
                    # Still has minimal activity - likely waiting
                    return 'waiting'
                else:
                    # No recent activity at all - idle between sessions
                    return 'idle'
            else:
                # Medium CPU (0.5-5.0) - processing
                return 'running'
        
        # Default to running for new processes
        return 'running'
    
    def sort_instances(self):
        """Sort instances by the current sort key"""
        if self.sort_key == 'pid':
            self.instances.sort(key=lambda x: x.pid, reverse=self.reverse_sort)
        elif self.sort_key == 'cpu':
            self.instances.sort(key=lambda x: x.cpu_percent, reverse=self.reverse_sort)
        elif self.sort_key == 'memory':
            self.instances.sort(key=lambda x: x.memory_mb, reverse=self.reverse_sort)
        elif self.sort_key == 'net_out':
            self.instances.sort(key=lambda x: x.net_bytes_sent, reverse=self.reverse_sort)
        elif self.sort_key == 'net_in':
            self.instances.sort(key=lambda x: x.net_bytes_recv, reverse=self.reverse_sort)
        elif self.sort_key == 'net_total':
            self.instances.sort(key=lambda x: x.net_bytes_total, reverse=self.reverse_sort)
        elif self.sort_key == 'disk_total':
            self.instances.sort(key=lambda x: x.disk_total_bytes, reverse=self.reverse_sort)
        elif self.sort_key == 'disk_current':
            self.instances.sort(key=lambda x: x.disk_current_bytes, reverse=self.reverse_sort)
        elif self.sort_key == 'connections':
            self.instances.sort(key=lambda x: x.connections_count, reverse=self.reverse_sort)
        elif self.sort_key == 'time':
            self.instances.sort(key=lambda x: x.start_time, reverse=self.reverse_sort)
    
    def group_instances_by_project(self):
        """Group instances by their working directory (project)"""
        self.project_groups.clear()
        
        for instance in self.instances:
            # Use parent directory as project identifier
            project_path = os.path.dirname(instance.working_dir)
            if project_path not in self.project_groups:
                self.project_groups[project_path] = []
            self.project_groups[project_path].append(instance)
        
        # Sort instances within each group
        for project, instances in self.project_groups.items():
            if self.sort_key == 'pid':
                instances.sort(key=lambda x: x.pid, reverse=self.reverse_sort)
            elif self.sort_key == 'cpu':
                instances.sort(key=lambda x: x.cpu_percent, reverse=self.reverse_sort)
            elif self.sort_key == 'memory':
                instances.sort(key=lambda x: x.memory_mb, reverse=self.reverse_sort)
            # ... other sort options
    
    def check_resource_alerts(self):
        """Check for processes exceeding resource thresholds"""
        if not self.alerts_enabled:
            return []
        
        alerts = []
        current_time = time.time()
        
        for instance in self.instances:
            pid = instance.pid
            
            # Initialize alert history for new processes
            if pid not in self.alert_history:
                self.alert_history[pid] = {'cpu': 0, 'memory': 0}
            
            # Check CPU threshold
            if instance.cpu_percent > self.cpu_threshold:
                last_alert = self.alert_history[pid]['cpu']
                if current_time - last_alert > self.alert_cooldown:
                    alerts.append({
                        'type': 'cpu',
                        'pid': pid,
                        'process': instance.working_dir.split('/')[-1],
                        'value': instance.cpu_percent,
                        'threshold': self.cpu_threshold
                    })
                    self.alert_history[pid]['cpu'] = current_time
            
            # Check memory threshold
            if instance.memory_mb > self.memory_threshold:
                last_alert = self.alert_history[pid]['memory']
                if current_time - last_alert > self.alert_cooldown:
                    alerts.append({
                        'type': 'memory',
                        'pid': pid,
                        'process': instance.working_dir.split('/')[-1],
                        'value': instance.memory_mb,
                        'threshold': self.memory_threshold
                    })
                    self.alert_history[pid]['memory'] = current_time
        
        # Clean up alert history for dead processes
        active_pids = {inst.pid for inst in self.instances}
        self.alert_history = {pid: hist for pid, hist in self.alert_history.items() if pid in active_pids}
        
        return alerts

class ClaudeTopUI:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.monitor = ClaudeMonitor()
        self.error_message = ""
        self.show_help = False
        self.search_mode = False
        self.search_query = ""
        self.filtered_instances = []
        self.selected_instances = set()  # For batch operations
        self.multi_select_mode = False
        self.active_alerts = []  # Current alerts
        self.show_alert_config = False  # Show alert configuration dialog
        
        # Analytics dashboard
        self.show_analytics = False
        self.analytics = HistoricalAnalytics() if DATABASE_AVAILABLE else None
        self.analytics_view = "overview"  # overview, trends, projects, productivity, sessions
        self.exporter = DataExporter() if DATABASE_AVAILABLE else None
        self.productivity = ProductivityAnalyzer() if DATABASE_AVAILABLE else None
        
        # Process management
        self.process_manager = ProcessManager() if DATABASE_AVAILABLE else None
        
        # Real-time dashboard
        self.realtime_dashboard = RealTimeDashboard() if DATABASE_AVAILABLE else None
        self.show_realtime = False
        self.realtime_view = "overview"  # overview, charts
        self.realtime_paused = False
        
        # Visual indicators
        self.visual_indicators = VisualIndicators() if DATABASE_AVAILABLE else None
        self.enhanced_visuals = DATABASE_AVAILABLE  # Only enable if modules are available
        
        # Performance optimization
        self.performance_optimizer = PerformanceOptimizer() if DATABASE_AVAILABLE else None
        self.performance_mode = DATABASE_AVAILABLE  # Only enable if modules are available
        
        # Initialize colors after all attributes are set
        self.setup_colors()
        
    def setup_colors(self):
        """Initialize color pairs"""
        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Running
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Paused
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)  # High CPU/Memory
        curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)  # Header
        curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLUE)  # Selected
        
        # Setup enhanced visual indicators colors
        if self.enhanced_visuals and self.visual_indicators:
            self.visual_indicators.setup_enhanced_colors()
    
    def format_bytes(self, bytes_value):
        """Format bytes into human readable format"""
        if bytes_value == 0:
            return "0B"
        elif bytes_value < 1024:
            return f"{bytes_value}B"
        elif bytes_value < 1024 * 1024:
            return f"{bytes_value/1024:.1f}K"
        elif bytes_value < 1024 * 1024 * 1024:
            return f"{bytes_value/(1024*1024):.1f}M"
        else:
            return f"{bytes_value/(1024*1024*1024):.1f}G"
    
    def create_usage_bar(self, percentage: float, width: int = 20) -> str:
        """Create a htop-style usage bar"""
        filled = int((percentage / 100.0) * width)
        bar = "█" * filled + "░" * (width - filled)
        return f"[{bar}]"
        
    def draw_header(self):
        """Draw the header with title and htop-style summary"""
        height, width = self.stdscr.getmaxyx()
        
        # Calculate summary statistics
        stats = self.monitor.calculate_summary_stats(self.monitor.instances)
        
        # Title
        title = "═══ Claude-Top - Claude CLI Monitor ═══"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(0, (width - len(title)) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # Left column - Process and CPU stats
        left_col = 2
        self.stdscr.addstr(1, left_col, f"Processes: {stats['process_stats']['total']} total")
        self.stdscr.addstr(2, left_col, f"  Running: {stats['cpu_stats']['count_running']}  Idle: {stats['cpu_stats']['count_idle']}  Waiting: {stats['cpu_stats']['count_waiting']}")
        
        # CPU usage bar with enhanced visuals
        cpu_percent = min(stats['cpu_stats']['current'], 100.0)
        if self.enhanced_visuals and self.visual_indicators:
            cpu_bar, cpu_color, cpu_pct = self.visual_indicators.create_enhanced_progress_bar(
                cpu_percent, 100, 30, IndicatorStyle.MODERN)
            self.stdscr.addstr(3, left_col, f"CPU: ")
            self.stdscr.addstr(3, left_col + 5, f"[{cpu_bar}]", curses.color_pair(cpu_color))
            self.stdscr.addstr(3, left_col + 38, f" {cpu_pct}")
        else:
            cpu_bar = self.create_usage_bar(cpu_percent, 30)
            self.stdscr.addstr(3, left_col, f"CPU: {cpu_percent:5.1f}% {cpu_bar}")
        
        # Memory usage with enhanced visuals
        mem_total = stats['memory_stats']['current']
        mem_avg = stats['memory_stats']['average']
        if self.enhanced_visuals and self.visual_indicators:
            # Scale memory for visualization (assume 2GB as "full")
            mem_bar, mem_color, mem_pct = self.visual_indicators.create_enhanced_progress_bar(
                mem_avg, 2000, 30, IndicatorStyle.MODERN)
            self.stdscr.addstr(4, left_col, f"Mem: ")
            self.stdscr.addstr(4, left_col + 5, f"[{mem_bar}]", curses.color_pair(mem_color))
            self.stdscr.addstr(4, left_col + 38, f" {mem_total:6.1f}MB")
        else:
            mem_bar = self.create_usage_bar(min(mem_avg, 1000) / 10, 30)  # Scale for visualization
            self.stdscr.addstr(4, left_col, f"Mem: {mem_total:7.1f}MB total {mem_bar}")
        
        # Right column - Network and Disk I/O
        right_col = width // 2 + 5
        if right_col < width - 40:  # Only if there's enough space
            # Session totals
            net_total_formatted = self.format_bytes(stats['session_totals']['net_total'])
            disk_total_formatted = self.format_bytes(stats['session_totals']['disk_total'])
            self.stdscr.addstr(1, right_col, f"Session Totals:")
            self.stdscr.addstr(2, right_col, f"  Network: {net_total_formatted}")
            self.stdscr.addstr(3, right_col, f"  Disk I/O: {disk_total_formatted}")
            
            # Current rates
            net_in_rate = self.format_bytes(stats['current_rates']['net_in_rate'])
            net_out_rate = self.format_bytes(stats['current_rates']['net_out_rate'])
            disk_rate = self.format_bytes(stats['current_rates']['disk_rate'])
            self.stdscr.addstr(4, right_col, f"  Current: ↓{net_in_rate} ↑{net_out_rate} ⚡{disk_rate}")
        
        # Additional stats line
        connections = stats['process_stats']['total_connections']
        mcp_count = stats['process_stats']['with_mcp']
        historical_sessions = stats['historical_averages']['sessions']
        
        additional_stats = f"Connections: {connections} | MCP: {mcp_count} | Historical Sessions (7d): {historical_sessions}"
        if len(additional_stats) < width - 4:
            self.stdscr.addstr(5, left_col, additional_stats)
        
        # Display active alerts
        if self.active_alerts and self.monitor.alerts_enabled:
            alert_y = 6
            self.stdscr.attron(curses.color_pair(3) | curses.A_BOLD)  # Red, bold
            
            if len(self.active_alerts) == 1:
                alert = self.active_alerts[0]
                alert_msg = f"⚠ ALERT: {alert['process']} (PID {alert['pid']}) - "
                if alert['type'] == 'cpu':
                    alert_msg += f"CPU: {alert['value']:.1f}% > {alert['threshold']:.0f}%"
                else:
                    alert_msg += f"Memory: {alert['value']:.0f}MB > {alert['threshold']:.0f}MB"
            else:
                alert_msg = f"⚠ {len(self.active_alerts)} RESOURCE ALERTS - Press 'A' for details"
            
            self.stdscr.addstr(alert_y, 2, alert_msg[:width-4])
            self.stdscr.attroff(curses.color_pair(3) | curses.A_BOLD)
        
        # Column headers with sort indicator
        sort_indicators = {
            'pid': 'PID',
            'cpu': 'CPU%',
            'memory': 'Mem(MB)',
            'tokens': 'Tokens',
            'time': 'Time'
        }
        
        # Build headers with sort indicator - split I/O columns
        headers_parts = [
            ('PID', 7, 'pid'),
            ('Status', 8, None),
            ('CPU%', 6, 'cpu'),
            ('Mem(MB)', 8, 'memory'),
            ('Net↑', 8, 'net_out'),
            ('Net↓', 8, 'net_in'),
            ('NetΣ', 8, 'net_total'),
            ('DiskΣ', 8, 'disk_total'),
            ('Disk∆', 8, 'disk_current'),
            ('Conn', 5, 'connections'),
            ('Time', 8, 'time'),
            ('Working Directory', 0, None)
        ]
        
        header_line = ""
        pos = 0
        for label, width, sort_field in headers_parts:
            if sort_field == self.monitor.sort_key:
                # Add sort indicator
                indicator = '▼' if self.monitor.reverse_sort else '▲'
                if width > 0:
                    display_label = f"{label}{indicator}"
                    header_line += f"{display_label:>{width}} "
                else:
                    header_line += f"{label}{indicator}"
            else:
                if width > 0:
                    header_line += f"{label:>{width}} "
                else:
                    header_line += label
        
        # Adjust header line position based on alerts
        header_y = 8 if (self.active_alerts and self.monitor.alerts_enabled) else 7
        
        self.stdscr.attron(curses.A_UNDERLINE)
        self.stdscr.addstr(header_y, 0, header_line[:width-1])
        self.stdscr.attroff(curses.A_UNDERLINE)
        
    def apply_search_filter(self):
        """Apply search filter to instances"""
        if not self.search_query:
            self.filtered_instances = self.monitor.instances
        else:
            query = self.search_query.lower()
            self.filtered_instances = [
                inst for inst in self.monitor.instances
                if (query in inst.working_dir.lower() or
                    query in inst.command.lower() or
                    query in inst.status.lower() or
                    str(inst.pid) == query)
            ]
        
        # Adjust selected index if needed
        if self.monitor.selected_index >= len(self.filtered_instances):
            self.monitor.selected_index = max(0, len(self.filtered_instances) - 1)
    
    def draw_grouped_instances(self, start_y, visible_lines, width):
        """Draw instances grouped by project"""
        y = start_y
        line_count = 0
        
        # Sort projects by name
        sorted_projects = sorted(self.monitor.project_groups.keys())
        
        for project_idx, project_path in enumerate(sorted_projects):
            if line_count >= visible_lines:
                break
                
            instances = self.monitor.project_groups[project_path]
            project_name = os.path.basename(project_path) or "root"
            
            # Draw project header
            self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
            header = f"▼ {project_name} ({len(instances)} instances)"
            
            # Add aggregate stats for the project
            total_cpu = sum(inst.cpu_percent for inst in instances)
            total_mem = sum(inst.memory_mb for inst in instances)
            header += f" - CPU: {total_cpu:.1f}% Mem: {total_mem:.0f}MB"
            
            self.stdscr.addstr(y, 0, header[:width-1])
            self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
            
            y += 1
            line_count += 1
            
            # Draw instances in this project
            for inst_idx, instance in enumerate(instances):
                if line_count >= visible_lines:
                    break
                
                # Indented instance display
                self.draw_instance_row(instance, y, 2, width, False)  # indent by 2
                
                y += 1
                line_count += 1
    
    def draw_instance_row(self, instance, y, indent, width, is_selected):
        """Draw a single instance row with enhanced visual indicators"""
        # Get status-based color with enhanced visuals
        if self.enhanced_visuals and self.visual_indicators:
            color = curses.color_pair(self.visual_indicators.get_status_color(instance.status))
        else:
            # Original color scheme
            if instance.status == 'running':
                color = curses.color_pair(1)  # Green
            elif instance.status == 'waiting':
                color = curses.color_pair(4)  # Cyan - waiting for user
            elif instance.status == 'idle':
                color = curses.color_pair(0)  # Default - minimal activity
            elif instance.status == 'paused':
                color = curses.color_pair(2)  # Yellow
            else:
                color = curses.color_pair(0)
        
        # High resource usage warning
        if instance.cpu_percent > 80 or instance.memory_mb > 1000:
            color = curses.color_pair(3)
        
        # Format the row
        elapsed = datetime.now() - instance.start_time
        elapsed_str = f"{elapsed.seconds//3600:02d}:{(elapsed.seconds//60)%60:02d}:{elapsed.seconds%60:02d}"
        
        # Directory display
        if self.monitor.show_full_path:
            dir_display = instance.working_dir
        else:
            parts = instance.working_dir.split('/')
            if len(parts) > 2:
                dir_display = '/'.join(parts[-2:])
            else:
                dir_display = instance.working_dir
        
        # Format I/O data with enhanced visual indicators
        if self.enhanced_visuals and self.visual_indicators:
            net_out_display, out_indicator = self.visual_indicators.format_bytes_with_indicator(instance.net_bytes_sent)
            net_in_display, in_indicator = self.visual_indicators.format_bytes_with_indicator(instance.net_bytes_recv)
            net_total_display, total_indicator = self.visual_indicators.format_bytes_with_indicator(instance.net_bytes_total)
            disk_total_display, disk_indicator = self.visual_indicators.format_bytes_with_indicator(instance.disk_total_bytes)
            disk_current_display, current_indicator = self.visual_indicators.format_bytes_with_indicator(instance.disk_current_bytes)
            
            # Add activity indicators
            net_out_display = f"{net_out_display:>7}"
            net_in_display = f"{net_in_display:>7}"
            net_total_display = f"{net_total_display:>7}"
            disk_total_display = f"{disk_total_display:>7}"
            disk_current_display = f"{disk_current_display:>7}"
        else:
            # Original formatting
            net_out_display = self.format_bytes(instance.net_bytes_sent)
            net_in_display = self.format_bytes(instance.net_bytes_recv)
            net_total_display = self.format_bytes(instance.net_bytes_total)
            disk_total_display = self.format_bytes(instance.disk_total_bytes)
            disk_current_display = self.format_bytes(instance.disk_current_bytes)
        
        # Connection display with enhanced indicators
        if self.enhanced_visuals:
            if instance.mcp_connections > 0:
                conn_display = f"{instance.connections_count}●"  # Dot indicates MCP
            else:
                conn_display = f"{instance.connections_count}○"
        else:
            if instance.mcp_connections > 0:
                conn_display = f"{instance.connections_count}M"
            else:
                conn_display = f"{instance.connections_count}"
        
        # Status display with visual indicators
        if self.enhanced_visuals and self.visual_indicators:
            status_icon = self.visual_indicators.get_status_icon(instance.status)
            status_display = f"{status_icon} {instance.status:>6}"
        else:
            status_display = f"{instance.status:>8}"
        
        # Build row with enhanced visuals
        spacing = " " * indent
        if self.multi_select_mode:
            checkbox = "[✓]" if instance.pid in self.selected_instances else "[ ]"
            selection_indicator = "▶" if is_selected and self.enhanced_visuals else "→" if is_selected else " "
            row = f"{spacing}{checkbox}{selection_indicator}{instance.pid:>6} {status_display} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_out_display:>8} {net_in_display:>8} {net_total_display:>8} {disk_total_display:>8} {disk_current_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
        else:
            if is_selected:
                selection_indicator = "▶ " if self.enhanced_visuals else "→ "
                row = f"{spacing}{selection_indicator}{instance.pid:>6} {status_display} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_out_display:>8} {net_in_display:>8} {net_total_display:>8} {disk_total_display:>8} {disk_current_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
            else:
                row = f"{spacing}  {instance.pid:>6} {status_display} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_out_display:>8} {net_in_display:>8} {net_total_display:>8} {disk_total_display:>8} {disk_current_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
        
        if is_selected:
            self.stdscr.attron(curses.color_pair(5))
        
        self.stdscr.attron(color)
        self.stdscr.addstr(y, 0, row[:width-1])
        self.stdscr.attroff(color)
        
        if is_selected:
            self.stdscr.attroff(curses.color_pair(5))
    
    def draw_instances(self):
        """Draw the list of Claude instances"""
        height, width = self.stdscr.getmaxyx()
        # Adjust start position based on alerts
        start_y = 9 if (self.active_alerts and self.monitor.alerts_enabled) else 8
        visible_lines = height - start_y - 3  # Leave room for footer
        
        # Use filtered instances if search is active
        instances_to_show = self.filtered_instances if self.search_mode or self.search_query else self.monitor.instances
        
        if self.monitor.group_by_project and not self.search_query:
            # Grouped display mode
            self.draw_grouped_instances(start_y, visible_lines, width)
        else:
            # Normal flat display
            for idx, instance in enumerate(instances_to_show[:visible_lines]):
                y = start_y + idx
                is_selected = idx == self.monitor.selected_index
                self.draw_instance_row(instance, y, 0, width, is_selected)
    
    def draw_footer(self):
        """Draw the footer with commands"""
        height, width = self.stdscr.getmaxyx()
        
        # Search bar if in search mode
        if self.search_mode:
            self.stdscr.attron(curses.color_pair(4))
            search_prompt = f"Search: {self.search_query}_"
            self.stdscr.addstr(height-3, 2, search_prompt[:width-4])
            self.stdscr.attroff(curses.color_pair(4))
        # Error message if any
        elif self.error_message:
            self.stdscr.attron(curses.color_pair(3))
            self.stdscr.addstr(height-3, 2, self.error_message[:width-4])
            self.stdscr.attroff(curses.color_pair(3))
        
        # Show filtered count if search is active
        if self.search_query and not self.search_mode:
            filter_info = f"[Filtered: {len(self.filtered_instances)}/{len(self.monitor.instances)}]"
            self.stdscr.addstr(height-3, 2, filter_info)
        
        # Show multi-select info
        if self.multi_select_mode:
            select_info = f"[Multi-select: {len(self.selected_instances)} selected]"
            self.stdscr.addstr(height-2, 2, select_info)
        
        # Commands with database indicator
        db_status = " [DB]" if self.monitor.enable_database else ""
        if self.multi_select_mode:
            commands = f"Space:Select  a:All  n:None  p:Pause  K:Kill  ESC:Exit  ↑↓:Navigate{db_status}"
        else:
            alert_indicator = " A:Alerts" if self.monitor.alerts_enabled else ""
            commands = f"q:Quit  /:Search  m:Multi  g:Group  p:Pause  K:Kill  s:Sort{alert_indicator}  h:Help{db_status}"
        self.stdscr.addstr(height-1, 2, commands[:width-4])
    
    def draw_help(self):
        """Draw help overlay"""
        height, width = self.stdscr.getmaxyx()
        help_text = [
            "Claude-Top Help",
            "",
            "Navigation:",
            "  ↑/↓ or j/k  - Move selection up/down",
            "  Home/End    - Go to first/last item",
            "",
            "Search & Filter:",
            "  /           - Enter search mode",
            "  ESC         - Clear search/Exit search mode",
            "  Search by: PID, status, command, or directory",
            "",
            "Multi-Select Mode:",
            "  m           - Enter multi-select mode",
            "  Space       - Toggle selection",
            "  a           - Select all",
            "  n           - Select none",
            "  p           - Pause/Resume selected",
            "  K           - Kill selected (with confirmation)",
            "  ESC         - Exit multi-select mode",
            "",
            "Actions:",
            "  p           - Pause/Resume selected instance",
            "  K           - Kill selected instance (with confirmation)",
            "  f           - Toggle full/short directory path",
            "  g           - Group by project/workspace",
            "  A           - Show/configure resource alerts",
            "",
            "Sorting:",
            "  s           - Cycle: PID→CPU→Mem→Net↑→Net↓→NetΣ→DiskΣ→Disk∆→Conn→Time",
            "  r           - Reverse sort order",
            "",
            "Display Columns:",
            "  Net↑        - Network bytes sent (outbound)",
            "  Net↓        - Network bytes received (inbound)", 
            "  NetΣ        - Total network I/O (cumulative)",
            "  DiskΣ       - Total disk I/O (cumulative)",
            "  Disk∆       - Current disk activity (this cycle)",
            "  Conn        - Network connections (M = MCP detected)",
            "",
            "Controls:",
            "  h           - Toggle this help",
            "  D           - Analytics dashboard (requires database)",
            "  R           - Real-time dashboard with live charts",
            "  V           - Toggle enhanced visual indicators",
            "  P           - Toggle performance optimization",
            "  I           - Show performance information",
            "  d           - Show database statistics (if enabled)",
            "  N           - Adjust process priority (nice value)",
            "  C           - Process cleanup (zombies/orphans)",
            "  q or Esc    - Quit",
            "",
            "Press any key to close help..."
        ]
        
        # Calculate box dimensions
        box_height = len(help_text) + 4
        box_width = max(len(line) for line in help_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw box
        self.stdscr.attron(curses.color_pair(4))
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw help text
        for i, line in enumerate(help_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(4))
    
    def handle_input(self):
        """Handle keyboard input"""
        key = self.stdscr.getch()
        
        if self.show_help:
            # Wait for any key press to close help
            if key != -1:
                self.show_help = False
            return True
        
        # Handle analytics mode input
        if self.show_analytics:
            if key == ord('q') or key == 27:  # ESC or q - exit analytics
                self.show_analytics = False
            elif key == ord('1'):  # 1 day
                if self.analytics_view == "overview":
                    self.analytics_timeframe = 1
            elif key == ord('2'):  # 7 days
                if self.analytics_view == "overview":
                    self.analytics_timeframe = 7
            elif key == ord('3'):  # 30 days
                if self.analytics_view == "overview":
                    self.analytics_timeframe = 30
            elif key == ord('t'):  # Trends view
                self.analytics_view = "trends"
            elif key == ord('p'):  # Projects view
                self.analytics_view = "projects"
            elif key == ord('o'):  # Overview
                self.analytics_view = "overview"
            elif key == ord('r'):  # Productivity view
                self.analytics_view = "productivity"
            elif key == ord('s'):  # Session details view
                self.analytics_view = "sessions"
            elif key == ord('e'):  # Export data
                self.show_export_dialog()
            return True
        
        # Handle real-time dashboard input
        if self.show_realtime:
            if key == ord('q') or key == 27:  # ESC or q - exit real-time
                self.show_realtime = False
            elif key == ord(' '):  # Space - pause/resume updates
                self.realtime_paused = not self.realtime_paused
            elif key == ord('o'):  # Overview
                self.realtime_view = "overview"
            elif key == ord('c'):  # Charts view
                self.realtime_view = "charts"
            elif key == ord('r'):  # Reset data
                self.realtime_dashboard = RealTimeDashboard()
            return True
        
        # Handle search mode input
        if self.search_mode:
            if key == 27:  # ESC - exit search
                self.search_mode = False
                if not self.search_query:
                    self.filtered_instances = self.monitor.instances
            elif key == ord('\n'):  # Enter - confirm search
                self.search_mode = False
                self.apply_search_filter()
            elif key == curses.KEY_BACKSPACE or key == 127:
                if self.search_query:
                    self.search_query = self.search_query[:-1]
                    self.apply_search_filter()
            elif 32 <= key <= 126:  # Printable characters
                self.search_query += chr(key)
                self.apply_search_filter()
            return True
        
        # Handle multi-select mode
        if self.multi_select_mode:
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            
            if key == 27:  # ESC - exit multi-select
                self.multi_select_mode = False
                self.selected_instances.clear()
            elif key == ord(' '):  # Space - toggle selection
                if instances and self.monitor.selected_index < len(instances):
                    pid = instances[self.monitor.selected_index].pid
                    if pid in self.selected_instances:
                        self.selected_instances.remove(pid)
                    else:
                        self.selected_instances.add(pid)
            elif key == ord('a'):  # Select all
                self.selected_instances = {inst.pid for inst in instances}
            elif key == ord('n'):  # Select none
                self.selected_instances.clear()
            elif key == ord('p'):  # Batch pause/resume
                if self.selected_instances:
                    for pid in self.selected_instances:
                        self.monitor.pause_resume_process(pid)
                    self.selected_instances.clear()
                    self.multi_select_mode = False
            elif key == ord('K'):  # Batch kill
                if self.selected_instances:
                    if self.show_batch_kill_confirmation():
                        self.selected_instances.clear()
                        self.multi_select_mode = False
            # Navigation in multi-select mode
            elif key == curses.KEY_UP or key == ord('k'):
                if self.monitor.selected_index > 0:
                    self.monitor.selected_index -= 1
            elif key == curses.KEY_DOWN or key == ord('j'):
                if self.monitor.selected_index < len(instances) - 1:
                    self.monitor.selected_index += 1
            return True
        
        # Normal mode
        if key == ord('q'):  # q to quit
            return False
        elif key == 27:  # ESC - clear search
            if self.search_query:
                self.search_query = ""
                self.filtered_instances = self.monitor.instances
                self.apply_search_filter()
            else:
                return False
        elif key == ord('/'):  # Enter search mode
            self.search_mode = True
            self.search_query = ""
        elif key == ord('m'):  # Enter multi-select mode
            self.multi_select_mode = True
            self.selected_instances.clear()
        elif key == ord('g'):  # Toggle group by project
            self.monitor.group_by_project = not self.monitor.group_by_project
            if self.monitor.group_by_project:
                self.monitor.group_instances_by_project()
        elif key == ord('A'):  # Show alert details
            if self.active_alerts:
                self.show_alert_details()
            else:
                self.show_alert_configuration()
        elif key == ord('h'):
            self.show_help = True
        elif key == ord('D'):  # Analytics dashboard
            if self.analytics and DATABASE_AVAILABLE:
                self.show_analytics = True
                self.analytics_view = "overview"
                self.analytics_timeframe = 7
            else:
                self.error_message = "Analytics requires database functionality"
        elif key == curses.KEY_UP or key == ord('k'):
            if self.monitor.selected_index > 0:
                self.monitor.selected_index -= 1
        elif key == curses.KEY_DOWN or key == ord('j'):
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if self.monitor.selected_index < len(instances) - 1:
                self.monitor.selected_index += 1
        elif key == ord('p'):
            # Pause/Resume selected instance
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if instances and self.monitor.selected_index < len(instances):
                instance = instances[self.monitor.selected_index]
                error = self.monitor.pause_resume_process(instance.pid)
                if error:
                    self.error_message = error
                else:
                    self.error_message = ""
        elif key == ord('K'):  # Capital K for kill (to avoid accidental kills)
            # Kill selected instance with confirmation
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if instances and self.monitor.selected_index < len(instances):
                instance = instances[self.monitor.selected_index]
                choice = self.show_kill_confirmation(instance)
                
                if choice == 'graceful':
                    error, message = self.monitor.kill_process(instance.pid, force=False)
                    if error:
                        self.error_message = error
                    else:
                        self.error_message = message or "Process terminated"
                elif choice == 'force':
                    error, message = self.monitor.kill_process(instance.pid, force=True)
                    if error:
                        self.error_message = error
                    else:
                        self.error_message = message or "Process killed"
                # If choice is None (cancel), do nothing
        elif key == ord('s'):
            # Cycle through sort options - split I/O columns
            sort_options = ['pid', 'cpu', 'memory', 'net_out', 'net_in', 'net_total', 'disk_total', 'disk_current', 'connections', 'time']
            current_idx = sort_options.index(self.monitor.sort_key)
            self.monitor.sort_key = sort_options[(current_idx + 1) % len(sort_options)]
            self.monitor.sort_instances()
        elif key == ord('r'):
            # Reverse sort order
            self.monitor.reverse_sort = not self.monitor.reverse_sort
        
        elif key == ord('f') or key == ord('F'):
            # Toggle full path display
            self.monitor.show_full_path = not self.monitor.show_full_path
            self.monitor.sort_instances()
        elif key == ord('d') or key == ord('D'):
            # Show database statistics
            if self.monitor.enable_database and self.monitor.db:
                self.show_database_stats()
            else:
                self.error_message = "Database tracking not enabled"
        elif key == ord('N'):  # Capital N for nice (priority adjustment)
            # Adjust process priority
            instances = self.filtered_instances if self.search_query else self.monitor.instances
            if instances and self.monitor.selected_index < len(instances):
                instance = instances[self.monitor.selected_index]
                info = self.process_manager.get_process_info(instance.pid)
                if info:
                    new_nice = self.process_manager.show_priority_dialog(self.stdscr, instance.pid, info.nice)
                    if new_nice is not None:
                        success, message = self.process_manager.adjust_process_priority(instance.pid, new_nice)
                        self.error_message = message
                else:
                    self.error_message = f"Cannot get info for process {instance.pid}"
        elif key == ord('C'):  # Capital C for cleanup
            # Show process cleanup dialog
            self.show_process_cleanup()
        elif key == ord('R'):  # Capital R for real-time dashboard
            # Enter real-time dashboard mode
            self.show_realtime = True
            self.realtime_view = "overview"
            self.realtime_paused = False
        elif key == ord('V'):  # Capital V for visual toggle
            # Toggle enhanced visuals
            self.enhanced_visuals = not self.enhanced_visuals
            if self.enhanced_visuals:
                self.visual_indicators.setup_enhanced_colors()
                self.error_message = "Enhanced visuals enabled"
            else:
                self.error_message = "Enhanced visuals disabled"
        elif key == ord('P'):  # Capital P for performance toggle
            # Toggle performance mode
            if self.performance_optimizer:
                self.performance_mode = not self.performance_mode
                if self.performance_mode:
                    self.performance_optimizer.start_background_processing()
                    self.error_message = "Performance optimization enabled"
                else:
                    self.performance_optimizer.stop_background_processing()
                    self.error_message = "Performance optimization disabled"
            else:
                self.error_message = "Performance optimizer not available"
        elif key == ord('I'):  # Capital I for performance info
            # Show performance information
            if self.performance_mode and self.performance_optimizer:
                summary = self.performance_optimizer.get_performance_summary()
                self.error_message = f"Perf: {summary['frame_rate']:.1f}FPS, {summary['avg_update_time']:.1f}ms update, {summary['status']}"
            else:
                self.error_message = "Performance mode disabled or not available"
        
        return True
    
    def show_process_cleanup(self):
        """Show process cleanup interface"""
        action = self.process_manager.show_cleanup_dialog(self.stdscr)
        
        if action == "zombies":
            results = self.process_manager.cleanup_zombie_processes()
            if results:
                success_count = sum(1 for _, success, _ in results if success)
                self.error_message = f"Zombie cleanup: {success_count}/{len(results)} successful"
            else:
                self.error_message = "No zombie processes found"
                
        elif action == "orphans":
            orphans = self.process_manager.find_orphaned_claude_processes()
            if orphans:
                # Show confirmation for orphaned process cleanup
                if self.show_orphan_cleanup_confirmation(orphans):
                    results = self.process_manager.cleanup_orphaned_processes(orphans)
                    success_count = sum(1 for _, success, _ in results if success)
                    self.error_message = f"Orphan cleanup: {success_count}/{len(results)} successful"
                else:
                    self.error_message = "Orphan cleanup cancelled"
            else:
                self.error_message = "No orphaned Claude processes found"
                
        elif action == "both":
            # Clean zombies first
            zombie_results = self.process_manager.cleanup_zombie_processes()
            zombie_success = sum(1 for _, success, _ in zombie_results if success)
            
            # Then orphans with confirmation
            orphans = self.process_manager.find_orphaned_claude_processes()
            orphan_success = 0
            if orphans and self.show_orphan_cleanup_confirmation(orphans):
                orphan_results = self.process_manager.cleanup_orphaned_processes(orphans)
                orphan_success = sum(1 for _, success, _ in orphan_results if success)
            
            self.error_message = f"Cleanup complete: {zombie_success} zombies, {orphan_success} orphans"
            
        elif action == "settings":
            self.show_cleanup_settings()
    
    def show_orphan_cleanup_confirmation(self, orphans: List[int]) -> bool:
        """Show confirmation dialog for orphaned process cleanup"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_text = [
            "⚠️  ORPHANED PROCESS CLEANUP WARNING ⚠️",
            "",
            f"Found {len(orphans)} orphaned Claude processes:",
        ]
        
        # Show PIDs
        for pid in orphans[:10]:  # Show first 10
            dialog_text.append(f"  PID {pid}")
        
        if len(orphans) > 10:
            dialog_text.append(f"  ... and {len(orphans) - 10} more")
        
        dialog_text.extend([
            "",
            "⚠️  WARNING: This will terminate these processes!",
            "⚠️  Only proceed if you're sure they're not needed.",
            "",
            "Y - Yes, clean up orphaned processes",
            "N - No, cancel cleanup",
        ])
        
        # Calculate dialog dimensions
        box_height = len(dialog_text) + 4
        box_width = max(len(line) for line in dialog_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog with warning colors
        self.stdscr.attron(curses.color_pair(3))  # Red background
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        for i, line in enumerate(dialog_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(3))
        
        self.stdscr.refresh()
        
        # Wait for Y/N response
        while True:
            key = self.stdscr.getch()
            if key == ord('Y') or key == ord('y'):
                return True
            elif key == ord('N') or key == ord('n') or key == 27:  # ESC
                return False
    
    def show_cleanup_settings(self):
        """Show cleanup settings dialog"""
        height, width = self.stdscr.getmaxyx()
        
        settings_text = [
            "Process Cleanup Settings",
            "",
            f"1. Auto-cleanup zombies: {'Enabled' if self.process_manager.auto_cleanup_zombies else 'Disabled'}",
            f"2. Auto-cleanup orphans: {'Enabled' if self.process_manager.auto_cleanup_orphans else 'Disabled'}",
            f"3. Cleanup interval: {self.process_manager.cleanup_interval}s",
            f"4. General cleanup: {'Enabled' if self.process_manager.cleanup_enabled else 'Disabled'}",
            "",
            "Select option to toggle (1-4) or ESC to close",
        ]
        
        # Calculate dialog dimensions
        box_height = len(settings_text) + 4
        box_width = max(len(line) for line in settings_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        while True:
            # Draw dialog
            self.stdscr.attron(curses.color_pair(4))
            for y in range(box_height):
                self.stdscr.addstr(start_y + y, start_x, " " * box_width)
            
            # Update settings text
            settings_text[2] = f"1. Auto-cleanup zombies: {'Enabled' if self.process_manager.auto_cleanup_zombies else 'Disabled'}"
            settings_text[3] = f"2. Auto-cleanup orphans: {'Enabled' if self.process_manager.auto_cleanup_orphans else 'Disabled'}"
            settings_text[4] = f"3. Cleanup interval: {self.process_manager.cleanup_interval}s"
            settings_text[5] = f"4. General cleanup: {'Enabled' if self.process_manager.cleanup_enabled else 'Disabled'}"
            
            for i, line in enumerate(settings_text):
                self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
            self.stdscr.attroff(curses.color_pair(4))
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == 27:  # ESC
                break
            elif key == ord('1'):
                self.process_manager.auto_cleanup_zombies = not self.process_manager.auto_cleanup_zombies
            elif key == ord('2'):
                self.process_manager.auto_cleanup_orphans = not self.process_manager.auto_cleanup_orphans
            elif key == ord('3'):
                # Cycle through interval options: 60s, 300s, 600s, 1800s
                intervals = [60, 300, 600, 1800]
                current_idx = intervals.index(self.process_manager.cleanup_interval) if self.process_manager.cleanup_interval in intervals else 0
                self.process_manager.cleanup_interval = intervals[(current_idx + 1) % len(intervals)]
            elif key == ord('4'):
                self.process_manager.cleanup_enabled = not self.process_manager.cleanup_enabled
    
    def show_database_stats(self):
        """Show database statistics overlay"""
        height, width = self.stdscr.getmaxyx()
        
        try:
            # Get analytics
            analytics = ClaudeAnalytics(self.monitor.db.db_path)
            reports = analytics.generate_usage_report(7)
            active_sessions = self.monitor.db.get_active_sessions()
            
            stats_text = [
                "Database Statistics (Last 7 Days)",
                "",
                f"Active Sessions: {len(active_sessions)}",
                f"Total Projects: {len(reports)}",
                "",
                "Top Projects by Runtime:",
            ]
            
            for i, report in enumerate(reports[:5], 1):
                stats_text.append(f"  {i}. {report.project_name}: {report.total_runtime_hours:.1f}h")
            
            if reports:
                stats_text.extend([
                    "",
                    "Current Session Summary:",
                    f"  Avg CPU: {sum(r.avg_cpu_percent for r in reports)/len(reports):.1f}%",
                    f"  Avg Memory: {sum(r.avg_memory_mb for r in reports)/len(reports):.1f}MB",
                    f"  Total Network: {sum(r.total_network_bytes for r in reports)}B",
                    f"  Total Disk: {sum(r.total_disk_bytes for r in reports)}B"
                ])
            
            stats_text.extend([
                "",
                "Press any key to close..."
            ])
        except Exception as e:
            stats_text = [
                "Database Statistics",
                "",
                f"Error loading statistics: {str(e)}",
                "",
                "Press any key to close..."
            ]
        
        # Calculate box dimensions
        box_height = len(stats_text) + 4
        box_width = max(len(line) for line in stats_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw box
        self.stdscr.attron(curses.color_pair(4))
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw stats text
        for i, line in enumerate(stats_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(4))
        
        self.stdscr.refresh()
        
        # Wait for keypress
        self.stdscr.getch()

    def show_kill_confirmation(self, instance):
        """Show kill confirmation dialog with three options"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_text = [
            f"Kill Process {instance.pid}?",
            "",
            f"Process: {instance.working_dir.split('/')[-1]}",
            f"Command: {instance.command[:50]}...",
            f"Status: {instance.status}",
            f"CPU: {instance.cpu_percent:.1f}%",
            f"Memory: {instance.memory_mb:.1f}MB",
            "",
            "Choose action:",
            "",
            "  [C] Cancel",
            "  [G] Kill Gracefully (SIGTERM)",
            "  [F] Kill Now (SIGKILL)",
            "",
            "Press C, G, or F..."
        ]
        
        # Calculate dialog dimensions
        box_height = len(dialog_text) + 4
        box_width = max(len(line) for line in dialog_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog box background
        self.stdscr.attron(curses.color_pair(3))  # Red/warning color
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw border
        for y in range(box_height):
            if y == 0 or y == box_height - 1:
                # Top and bottom border
                self.stdscr.addstr(start_y + y, start_x, "─" * box_width)
            else:
                # Side borders
                self.stdscr.addstr(start_y + y, start_x, "│")
                self.stdscr.addstr(start_y + y, start_x + box_width - 1, "│")
        
        # Corner characters
        self.stdscr.addstr(start_y, start_x, "┌")
        self.stdscr.addstr(start_y, start_x + box_width - 1, "┐")
        self.stdscr.addstr(start_y + box_height - 1, start_x, "└")
        self.stdscr.addstr(start_y + box_height - 1, start_x + box_width - 1, "┘")
        
        # Draw dialog text
        for i, line in enumerate(dialog_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        
        self.stdscr.attroff(curses.color_pair(3))
        self.stdscr.refresh()
        
        # Wait for user choice
        while True:
            key = self.stdscr.getch()
            if key == ord('c') or key == ord('C') or key == 27:  # Cancel or ESC
                return None
            elif key == ord('g') or key == ord('G'):
                return 'graceful'
            elif key == ord('f') or key == ord('F'):
                return 'force'
    
    def show_batch_kill_confirmation(self):
        """Show batch kill confirmation dialog"""
        height, width = self.stdscr.getmaxyx()
        
        instances = self.filtered_instances if self.search_query else self.monitor.instances
        selected = [inst for inst in instances if inst.pid in self.selected_instances]
        
        dialog_text = [
            f"Kill {len(selected)} Processes?",
            "",
            "Selected processes:",
        ]
        
        # Show first few selected processes
        for inst in selected[:5]:
            dialog_text.append(f"  PID {inst.pid}: {inst.working_dir.split('/')[-1]}")
        
        if len(selected) > 5:
            dialog_text.append(f"  ... and {len(selected) - 5} more")
        
        dialog_text.extend([
            "",
            "Choose action:",
            "",
            "  [C] Cancel",
            "  [G] Kill All Gracefully (SIGTERM)",
            "  [F] Kill All Now (SIGKILL)",
            "",
            "Press C, G, or F..."
        ])
        
        # Calculate dialog dimensions
        box_height = len(dialog_text) + 4
        box_width = max(len(line) for line in dialog_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog box
        self.stdscr.attron(curses.color_pair(3))  # Red/warning color
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw border
        for y in range(box_height):
            if y == 0 or y == box_height - 1:
                self.stdscr.addstr(start_y + y, start_x, "─" * box_width)
            else:
                self.stdscr.addstr(start_y + y, start_x, "│")
                self.stdscr.addstr(start_y + y, start_x + box_width - 1, "│")
        
        # Corner characters
        self.stdscr.addstr(start_y, start_x, "┌")
        self.stdscr.addstr(start_y, start_x + box_width - 1, "┐")
        self.stdscr.addstr(start_y + box_height - 1, start_x, "└")
        self.stdscr.addstr(start_y + box_height - 1, start_x + box_width - 1, "┘")
        
        # Draw dialog text
        for i, line in enumerate(dialog_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        
        self.stdscr.attroff(curses.color_pair(3))
        self.stdscr.refresh()
        
        # Wait for user choice
        while True:
            key = self.stdscr.getch()
            if key == ord('c') or key == ord('C') or key == 27:  # Cancel or ESC
                return False
            elif key == ord('g') or key == ord('G'):
                # Kill all gracefully
                for pid in self.selected_instances:
                    self.monitor.kill_process(pid, force=False)
                self.error_message = f"Terminated {len(self.selected_instances)} processes gracefully"
                return True
            elif key == ord('f') or key == ord('F'):
                # Kill all forcefully
                for pid in self.selected_instances:
                    self.monitor.kill_process(pid, force=True)
                self.error_message = f"Killed {len(self.selected_instances)} processes forcefully"
                return True
    
    def show_alert_details(self):
        """Show detailed alert information"""
        height, width = self.stdscr.getmaxyx()
        
        dialog_text = [
            "Resource Alerts",
            "",
            f"Active Alerts: {len(self.active_alerts)}",
            ""
        ]
        
        # Show all active alerts
        for alert in self.active_alerts[:10]:  # Show max 10
            if alert['type'] == 'cpu':
                dialog_text.append(f"• PID {alert['pid']} ({alert['process']})")
                dialog_text.append(f"  CPU: {alert['value']:.1f}% > {alert['threshold']:.0f}%")
            else:
                dialog_text.append(f"• PID {alert['pid']} ({alert['process']})")
                dialog_text.append(f"  Memory: {alert['value']:.0f}MB > {alert['threshold']:.0f}MB")
            dialog_text.append("")
        
        if len(self.active_alerts) > 10:
            dialog_text.append(f"... and {len(self.active_alerts) - 10} more alerts")
        
        dialog_text.extend([
            "",
            "Alert Configuration:",
            f"  CPU Threshold: {self.monitor.cpu_threshold:.0f}%",
            f"  Memory Threshold: {self.monitor.memory_threshold:.0f}MB",
            f"  Cooldown: {self.monitor.alert_cooldown}s",
            "",
            "Press 'C' to configure thresholds",
            "Press any other key to close..."
        ])
        
        # Calculate dialog dimensions
        box_height = len(dialog_text) + 4
        box_width = max(len(line) for line in dialog_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog box
        self.stdscr.attron(curses.color_pair(3))  # Red color
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw text
        for i, line in enumerate(dialog_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        
        self.stdscr.attroff(curses.color_pair(3))
        self.stdscr.refresh()
        
        # Wait for user input
        key = self.stdscr.getch()
        if key == ord('c') or key == ord('C'):
            self.show_alert_configuration()
    
    def show_alert_configuration(self):
        """Show alert configuration dialog"""
        height, width = self.stdscr.getmaxyx()
        
        # Store current values for editing
        cpu_threshold = str(int(self.monitor.cpu_threshold))
        memory_threshold = str(int(self.monitor.memory_threshold))
        current_field = 0  # 0=CPU, 1=Memory, 2=Save, 3=Cancel
        
        while True:
            dialog_text = [
                "Configure Resource Alerts",
                "",
                "Use ↑/↓ to navigate, Enter to edit, numbers to change values",
                "",
            ]
            
            # CPU threshold field
            if current_field == 0:
                dialog_text.append(f"→ CPU Threshold: {cpu_threshold}% ")
            else:
                dialog_text.append(f"  CPU Threshold: {cpu_threshold}%")
            
            # Memory threshold field
            if current_field == 1:
                dialog_text.append(f"→ Memory Threshold: {memory_threshold}MB ")
            else:
                dialog_text.append(f"  Memory Threshold: {memory_threshold}MB")
            
            dialog_text.append("")
            
            # Save/Cancel buttons
            if current_field == 2:
                dialog_text.append("  [→ Save ]  [ Cancel ]")
            elif current_field == 3:
                dialog_text.append("  [ Save ]  [→ Cancel ]")
            else:
                dialog_text.append("  [ Save ]  [ Cancel ]")
            
            dialog_text.extend([
                "",
                "Press 'T' to toggle alerts on/off",
                f"Alerts are currently: {'ENABLED' if self.monitor.alerts_enabled else 'DISABLED'}"
            ])
            
            # Calculate dialog dimensions
            box_height = len(dialog_text) + 4
            box_width = max(len(line) for line in dialog_text) + 6
            start_y = (height - box_height) // 2
            start_x = (width - box_width) // 2
            
            # Draw dialog box
            self.stdscr.attron(curses.color_pair(4))  # Cyan
            for y in range(box_height):
                self.stdscr.addstr(start_y + y, start_x, " " * box_width)
            
            # Draw text
            for i, line in enumerate(dialog_text):
                self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
            
            self.stdscr.attroff(curses.color_pair(4))
            self.stdscr.refresh()
            
            # Handle input
            key = self.stdscr.getch()
            
            if key == 27:  # ESC
                break
            elif key == ord('t') or key == ord('T'):
                self.monitor.alerts_enabled = not self.monitor.alerts_enabled
            elif key == curses.KEY_UP:
                current_field = max(0, current_field - 1)
            elif key == curses.KEY_DOWN:
                current_field = min(3, current_field + 1)
            elif key == ord('\n'):  # Enter
                if current_field == 2:  # Save
                    try:
                        self.monitor.cpu_threshold = float(cpu_threshold)
                        self.monitor.memory_threshold = float(memory_threshold)
                        self.error_message = "Alert thresholds updated"
                    except ValueError:
                        self.error_message = "Invalid threshold values"
                    break
                elif current_field == 3:  # Cancel
                    break
            elif key == curses.KEY_BACKSPACE or key == 127:
                if current_field == 0 and cpu_threshold:
                    cpu_threshold = cpu_threshold[:-1]
                elif current_field == 1 and memory_threshold:
                    memory_threshold = memory_threshold[:-1]
            elif 48 <= key <= 57:  # Numbers 0-9
                if current_field == 0:
                    cpu_threshold += chr(key)
                elif current_field == 1:
                    memory_threshold += chr(key)
    
    def show_export_dialog(self):
        """Show export options dialog"""
        if not self.exporter:
            self.error_message = "Export requires database functionality"
            return
        
        height, width = self.stdscr.getmaxyx()
        
        # Get export stats
        stats = self.exporter.get_export_stats()
        
        export_options = [
            "Export Data - Select Format",
            "",
            f"Available data: {stats.get('total_sessions', 0)} sessions, {stats.get('total_projects', 0)} projects",
            "",
            "1. Sessions CSV (last 7 days)",
            "2. Sessions CSV (last 30 days)", 
            "3. Project Summary CSV",
            "4. Detailed Metrics CSV (last 7 days)",
            "5. Complete JSON Export (last 30 days)",
            "",
            "Choose option (1-5) or ESC to cancel..."
        ]
        
        # Calculate dialog dimensions
        box_height = len(export_options) + 4
        box_width = max(len(line) for line in export_options) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw dialog box
        self.stdscr.attron(curses.color_pair(4))
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw export options
        for i, line in enumerate(export_options):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(4))
        
        self.stdscr.refresh()
        
        # Handle export selection
        while True:
            key = self.stdscr.getch()
            
            if key == 27:  # ESC - cancel
                break
            elif key == ord('1'):  # Sessions CSV 7 days
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"claude_sessions_7d_{timestamp}.csv"
                if self.exporter.export_sessions_csv(filename, 7):
                    self.error_message = f"Exported to {filename}"
                else:
                    self.error_message = "Export failed"
                break
            elif key == ord('2'):  # Sessions CSV 30 days
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"claude_sessions_30d_{timestamp}.csv"
                if self.exporter.export_sessions_csv(filename, 30):
                    self.error_message = f"Exported to {filename}"
                else:
                    self.error_message = "Export failed"
                break
            elif key == ord('3'):  # Project summary CSV
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"claude_projects_{timestamp}.csv"
                if self.exporter.export_project_summary_csv(filename):
                    self.error_message = f"Exported to {filename}"
                else:
                    self.error_message = "Export failed"
                break
            elif key == ord('4'):  # Detailed metrics CSV
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"claude_metrics_7d_{timestamp}.csv"
                if self.exporter.export_metrics_csv(filename, 7):
                    self.error_message = f"Exported to {filename}"
                else:
                    self.error_message = "Export failed"
                break
            elif key == ord('5'):  # Complete JSON export
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"claude_export_{timestamp}.json"
                if self.exporter.export_data_json(filename, 30):
                    self.error_message = f"Exported to {filename}"
                else:
                    self.error_message = "Export failed"
                break
    
    def draw_analytics(self):
        """Draw analytics dashboard"""
        if not self.analytics:
            height, width = self.stdscr.getmaxyx()
            msg = "Analytics not available - database functionality required"
            self.stdscr.addstr(height // 2, (width - len(msg)) // 2, msg)
            return
        
        try:
            if self.analytics_view == "overview":
                data = self.analytics.get_analytics_data(getattr(self, 'analytics_timeframe', 7))
                self.analytics.render_overview(self.stdscr, data)
            elif self.analytics_view == "trends":
                self.analytics.render_daily_trends(self.stdscr)
            elif self.analytics_view == "projects":
                self.analytics.render_project_analytics(self.stdscr)
            elif self.analytics_view == "productivity":
                if self.productivity:
                    metrics = self.productivity.calculate_productivity_metrics(getattr(self, 'analytics_timeframe', 7))
                    self.productivity.render_productivity_overview(self.stdscr, metrics)
                else:
                    height, width = self.stdscr.getmaxyx()
                    msg = "Productivity analysis not available"
                    self.stdscr.addstr(height // 2, (width - len(msg)) // 2, msg)
            elif self.analytics_view == "sessions":
                if self.productivity:
                    patterns = self.productivity.analyze_session_patterns(getattr(self, 'analytics_timeframe', 7))
                    self.productivity.render_session_patterns(self.stdscr, patterns)
                else:
                    height, width = self.stdscr.getmaxyx()
                    msg = "Session analysis not available"
                    self.stdscr.addstr(height // 2, (width - len(msg)) // 2, msg)
        except Exception as e:
            height, width = self.stdscr.getmaxyx()
            error_msg = f"Analytics error: {str(e)[:width-20]}"
            self.stdscr.addstr(height // 2, (width - len(error_msg)) // 2, error_msg)
    
    def draw_realtime_dashboard(self):
        """Draw real-time dashboard"""
        height, width = self.stdscr.getmaxyx()
        
        if not self.realtime_dashboard:
            msg = "Real-time dashboard not available (missing dependencies)"
            self.stdscr.addstr(height // 2, (width - len(msg)) // 2, msg)
            return
            
        try:
            if self.realtime_view == "overview":
                self.realtime_dashboard.render_realtime_overview(self.stdscr, width, height)
            elif self.realtime_view == "charts":
                self.realtime_dashboard.render_live_charts_view(self.stdscr, width, height)
                
            # Show pause indicator if paused
            if self.realtime_paused:
                pause_msg = "⏸ PAUSED - Press Space to resume"
                self.stdscr.addstr(1, width - len(pause_msg) - 2, pause_msg, curses.A_BOLD | curses.color_pair(2))
                
        except Exception as e:
            error_msg = f"Real-time error: {str(e)[:width-20]}"
            self.stdscr.addstr(height // 2, (width - len(error_msg)) // 2, error_msg)
    
    def update_realtime_metrics(self):
        """Update real-time dashboard with current metrics"""
        if not self.show_realtime or self.realtime_paused:
            return
            
        # Calculate current metrics
        instances = self.monitor.instances
        
        if instances:
            # Aggregate metrics
            total_cpu = sum(inst.cpu_percent for inst in instances)
            total_memory = sum(inst.memory_mb for inst in instances)
            active_sessions = len([inst for inst in instances if inst.status in ['running', 'waiting']])
            
            # Calculate network activity (sum of current activity)
            network_activity = sum(inst.net_bytes_sent + inst.net_bytes_recv for inst in instances) / 1024  # KB
            
            # Calculate simple productivity score
            if instances:
                running_ratio = len([inst for inst in instances if inst.status == 'running']) / len(instances)
                productivity_score = running_ratio * 100
            else:
                productivity_score = 0
            
            # Alert count
            alert_count = len(self.active_alerts)
            
            # Create metrics object
            metrics = RealTimeMetrics(
                timestamp=datetime.now(),
                cpu_usage=total_cpu,
                memory_usage=total_memory,
                active_sessions=active_sessions,
                network_activity=network_activity,
                productivity_score=productivity_score,
                alert_count=alert_count
            )
            
            # Add to real-time dashboard
            if self.realtime_dashboard:
                self.realtime_dashboard.add_metrics(metrics)
    
    def run(self):
        """Main UI loop"""
        self.stdscr.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor
        
        # Start performance optimization
        if self.performance_mode and self.performance_optimizer:
            self.performance_optimizer.start_background_processing()
        
        last_update = 0
        running = True
        
        while running:
            current_time = time.time()
            
            # Update data with performance optimization
            if self.performance_mode and self.performance_optimizer:
                update_interval = self.performance_optimizer.adaptive_update_interval
            else:
                update_interval = self.monitor.update_interval
            
            if current_time - last_update > update_interval:
                
                def update_data():
                    # Core data updates (high priority)
                    if not self.performance_optimizer or self.performance_optimizer.should_update('high'):
                        self.monitor.instances = self.monitor.find_claude_processes()
                        self.monitor.sort_instances()
                    
                    # Grouping updates (medium priority)
                    if self.monitor.group_by_project and (not self.performance_optimizer or self.performance_optimizer.should_update('medium')):
                        self.monitor.group_instances_by_project()
                    
                    # Search filter (high priority when active)
                    if self.search_query:
                        self.apply_search_filter()
                    else:
                        self.filtered_instances = self.monitor.instances
                    
                    # Alert checking (critical priority)
                    if not self.performance_optimizer or self.performance_optimizer.should_update('critical'):
                        self.active_alerts = self.monitor.check_resource_alerts()
                    
                    # Real-time metrics (medium priority)
                    if self.show_realtime and (not self.performance_optimizer or self.performance_optimizer.should_update('medium')):
                        self.update_realtime_metrics()
                    
                    return True
                
                # Measure update performance
                if self.performance_mode and self.performance_optimizer:
                    self.performance_optimizer.measure_update_time(update_data)
                else:
                    update_data()
                
                # Cleanup (background priority)
                if self.performance_optimizer.should_update('background'):
                    def cleanup_task():
                        cleanup_results = self.process_manager.auto_cleanup()
                        if cleanup_results.get('actions_taken'):
                            actions = cleanup_results['actions_taken']
                            if actions and not self.error_message:
                                self.error_message = f"Auto-cleanup: {'; '.join(actions[:2])}"
                    
                    if self.performance_mode and self.performance_optimizer:
                        self.performance_optimizer.add_background_task(cleanup_task)
                    else:
                        cleanup_task()
                
                last_update = current_time
                
                # Clean up old CPU histories
                current_pids = {inst.pid for inst in self.monitor.instances}
                self.monitor.cpu_histories = {pid: hist for pid, hist in self.monitor.cpu_histories.items() if pid in current_pids}
            
            # Update animation frames for visual indicators (every refresh)
            if self.enhanced_visuals and self.visual_indicators:
                self.visual_indicators.update_animation_frame()
                if self.realtime_dashboard:
                    self.realtime_dashboard.should_animate()  # Update real-time animations
            
            # Update performance metrics
            if self.performance_mode and self.monitor.instances and self.performance_optimizer:
                total_cpu = sum(inst.cpu_percent for inst in self.monitor.instances)
                total_memory = sum(inst.memory_mb for inst in self.monitor.instances)
                self.performance_optimizer.update_system_metrics(total_cpu, total_memory)
                
                # Clean up selected instances for batch operations
                self.selected_instances = {pid for pid in self.selected_instances if pid in current_pids}
                
                # Adjust selected index if needed
                instances = self.filtered_instances if self.search_query else self.monitor.instances
                if self.monitor.selected_index >= len(instances):
                    self.monitor.selected_index = max(0, len(instances) - 1)
            
            # Clear and redraw with performance optimization
            def render_ui():
                self.stdscr.clear()
                
                if self.show_help:
                    self.draw_help()
                elif self.show_analytics:
                    self.draw_analytics()
                elif self.show_realtime:
                    self.draw_realtime_dashboard()
                else:
                    self.draw_header()
                    self.draw_instances()
                    self.draw_footer()
                
                self.stdscr.refresh()
                return True
            
            # Measure rendering performance
            if self.performance_mode:
                self.performance_optimizer.measure_render_time(render_ui)
            else:
                render_ui()
            
            # Handle input
            running = self.handle_input()
            
            # Small delay to prevent high CPU usage
            time.sleep(0.05)
        
        # Cleanup on exit
        if self.performance_mode:
            self.performance_optimizer.stop_background_processing()

def main(stdscr):
    """Main entry point"""
    # Access global args
    enable_db = not global_args.no_database if 'global_args' in globals() else True
    db_path = global_args.db_path if 'global_args' in globals() else "claude_tracking.db"
    
    # Create monitor with database options
    monitor = ClaudeMonitor(enable_database=enable_db)
    if enable_db and monitor.enable_database and monitor.db:
        monitor.db.db_path = db_path
    
    ui = ClaudeTopUI(stdscr)
    ui.monitor = monitor  # Replace default monitor
    
    try:
        ui.run()
    finally:
        # Graceful shutdown - end database sessions
        if ui.monitor.enable_database and ui.monitor.db:
            for pid, session_id in ui.monitor.active_sessions.items():
                ui.monitor.db.end_session(session_id)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Monitor Claude CLI instances with SQLite tracking")
    parser.add_argument('--interval', type=float, default=1.0, help="Update interval in seconds")
    parser.add_argument('--no-database', action='store_true', help="Disable database tracking")
    parser.add_argument('--db-path', default="claude_tracking.db", help="Database file path")
    parser.add_argument('--json-once', action='store_true', help="Output JSON data once and exit (for VS Code extension)")
    args = parser.parse_args()
    
    # Store args globally for access in main
    global_args = args
    
    # If JSON output is requested, output once and exit
    if args.json_once:
        monitor = ClaudeMonitor(enable_database=False)
        instances = monitor.find_claude_processes()
        
        # Convert instances to JSON-serializable format
        json_data = []
        for inst in instances:
            json_data.append({
                'pid': inst.pid,
                'working_dir': inst.working_dir,
                'task': inst.task,
                'context_length': inst.context_length,
                'tokens_used': inst.tokens_used,
                'start_time': inst.start_time.isoformat(),
                'status': inst.status,
                'cpu_percent': inst.cpu_percent,
                'memory_mb': inst.memory_mb,
                'command': inst.command,
                'net_bytes_sent': inst.net_bytes_sent,
                'net_bytes_recv': inst.net_bytes_recv,
                'net_bytes_total': inst.net_bytes_total,
                'disk_total_bytes': inst.disk_total_bytes,
                'disk_current_bytes': inst.disk_current_bytes,
                'connections_count': inst.connections_count,
                'mcp_connections': inst.mcp_connections
            })
        
        print(json.dumps(json_data))
        sys.exit(0)
    
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
