#!/usr/bin/env python3
"""
claude-top: A terminal-based monitoring tool for Claude CLI instances
"""

import curses
import json
import os
import psutil
import signal
import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Dict
from collections import deque
import subprocess
import argparse

@dataclass
class ClaudeInstance:
    pid: int
    working_dir: str
    task: str
    context_length: int
    tokens_used: int
    start_time: datetime
    status: str  # 'running', 'idle', 'waiting', 'paused'
    cpu_percent: float
    memory_mb: float
    command: str
    cpu_history: deque = field(default_factory=lambda: deque(maxlen=5))
    net_bytes_sent: int = 0
    net_bytes_recv: int = 0
    disk_read_bytes: int = 0
    disk_write_bytes: int = 0
    connections_count: int = 0
    mcp_connections: int = 0

class ClaudeMonitor:
    def __init__(self):
        self.instances: List[ClaudeInstance] = []
        self.selected_index = 0
        self.paused_pids = set()
        self.update_interval = 1.0
        self.sort_key = 'pid'
        self.reverse_sort = False
        self.show_full_path = False
        self.cpu_histories = {}  # Track CPU history for each PID
        
    def find_claude_processes(self):
        """Find all Claude CLI processes running on the system"""
        claude_processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cwd', 'create_time', 'cpu_percent', 'memory_info']):
            try:
                # Check if this is a Claude CLI process
                cmdline = proc.info.get('cmdline', [])
                if cmdline and any('claude' in cmd.lower() for cmd in cmdline):
                    # Filter out non-CLI Claude processes
                    cmdline_str = ' '.join(cmdline)
                    # Skip Claude desktop app processes
                    if 'Claude.app' in cmdline_str or 'Claude Helper' in cmdline_str or 'chrome_crashpad' in cmdline_str or 'Squirrel' in cmdline_str:
                        continue
                    # Skip docker processes unless they're Claude-related containers
                    if 'docker' in cmdline_str and 'mcp/filesystem' in cmdline_str:
                        continue
                    
                    # Extract relevant information
                    instance = self.parse_claude_process(proc)
                    if instance:
                        claude_processes.append(instance)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
                
        return claude_processes
    
    def parse_claude_process(self, proc) -> Optional[ClaudeInstance]:
        """Parse process information to create ClaudeInstance"""
        try:
            info = proc.info
            pid = info['pid']
            # Get working directory - try multiple methods
            cwd = info.get('cwd', None)
            if not cwd or cwd == '/':
                try:
                    # Try to get cwd directly from process
                    cwd = proc.cwd()
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    cwd = 'Unknown'
            
            cmdline = ' '.join(info.get('cmdline', []))
            
            # For now, we'll use a placeholder for task
            task = "Active Session"
            
            # Token/context information not available from external sources
            context_length, tokens_used = 0, 0
            
            # Initialize CPU history for new processes
            if pid not in self.cpu_histories:
                self.cpu_histories[pid] = deque(maxlen=5)
            
            # Update CPU history
            current_cpu = info.get('cpu_percent', 0.0)
            self.cpu_histories[pid].append(current_cpu)
            
            # Determine status based on CPU usage patterns
            status = self.determine_process_status(pid, proc)
            
            # Get network and disk I/O statistics
            net_io, disk_io, connections_info = self.get_io_stats(proc)
            
            return ClaudeInstance(
                pid=pid,
                working_dir=cwd,
                task=task,
                context_length=context_length,
                tokens_used=tokens_used,
                start_time=datetime.fromtimestamp(info['create_time']),
                status=status,
                cpu_percent=info.get('cpu_percent', 0.0),
                memory_mb=info.get('memory_info').rss / 1024 / 1024 if info.get('memory_info') else 0,
                command=cmdline,
                cpu_history=self.cpu_histories[pid].copy(),
                net_bytes_sent=net_io['bytes_sent'],
                net_bytes_recv=net_io['bytes_recv'],
                disk_read_bytes=disk_io['read_bytes'],
                disk_write_bytes=disk_io['write_bytes'],
                connections_count=connections_info['total_connections'],
                mcp_connections=connections_info['mcp_connections']
            )
        except Exception:
            return None
    
    def extract_task_from_cmdline(self, cmdline: str) -> str:
        """Extract task description from command line"""
        # This is a simplified extraction - in reality, you'd parse Claude's specific format
        if '--task' in cmdline:
            parts = cmdline.split('--task')
            if len(parts) > 1:
                return parts[1].split()[0].strip('"\'')
        elif 'claude' in cmdline:
            # Try to extract any quoted strings as potential tasks
            import re
            quotes = re.findall(r'"([^"]*)"', cmdline)
            if quotes:
                return quotes[0][:50] + '...' if len(quotes[0]) > 50 else quotes[0]
        return "Unknown Task"
    
    def get_claude_metrics(self, pid: int, working_dir: str) -> tuple:
        """Token/context information not available from external sources"""
        # Claude CLI does not expose token/context data in accessible files
        # This information is only available internally via /cost command
        return 0, 0
    
    def get_io_stats(self, proc):
        """Get network I/O, disk I/O, and connection statistics for a process"""
        try:
            # Network I/O counters
            try:
                net_io = proc.net_io_counters()
                net_stats = {
                    'bytes_sent': net_io.bytes_sent if net_io else 0,
                    'bytes_recv': net_io.bytes_recv if net_io else 0
                }
            except (psutil.NoSuchProcess, psutil.AccessDenied, AttributeError):
                net_stats = {'bytes_sent': 0, 'bytes_recv': 0}
            
            # Disk I/O counters
            try:
                disk_io = proc.io_counters()
                disk_stats = {
                    'read_bytes': disk_io.read_bytes if disk_io else 0,
                    'write_bytes': disk_io.write_bytes if disk_io else 0
                }
            except (psutil.NoSuchProcess, psutil.AccessDenied, AttributeError):
                disk_stats = {'read_bytes': 0, 'write_bytes': 0}
            
            # Connection analysis
            try:
                connections = proc.net_connections()
                total_connections = len(connections)
                mcp_connections = 0
                
                for conn in connections:
                    if conn.status == 'ESTABLISHED':
                        # Heuristic for MCP: WebSocket-like ports or specific patterns
                        if (conn.raddr and conn.raddr.port in [8000, 8080, 3000, 9000] or
                            (conn.laddr and conn.laddr.port > 8000)):
                            mcp_connections += 1
                
                connections_info = {
                    'total_connections': total_connections,
                    'mcp_connections': mcp_connections
                }
            except (psutil.NoSuchProcess, psutil.AccessDenied, AttributeError):
                connections_info = {'total_connections': 0, 'mcp_connections': 0}
            
            return net_stats, disk_stats, connections_info
            
        except Exception:
            # Return default values on any error
            return ({'bytes_sent': 0, 'bytes_recv': 0}, 
                   {'read_bytes': 0, 'write_bytes': 0},
                   {'total_connections': 0, 'mcp_connections': 0})
    
    def pause_resume_process(self, pid: int):
        """Pause or resume a process"""
        try:
            if pid in self.paused_pids:
                os.kill(pid, signal.SIGCONT)
                self.paused_pids.remove(pid)
            else:
                os.kill(pid, signal.SIGSTOP)
                self.paused_pids.add(pid)
        except Exception as e:
            return f"Error: {str(e)}"
        return None
    
    def determine_process_status(self, pid, proc):
        """Determine process status based on CPU usage patterns"""
        # Check if manually paused
        if pid in self.paused_pids:
            return 'paused'
        
        # Check system status
        sys_status = proc.status()
        if sys_status == 'stopped':
            return 'paused'
        
        # Analyze CPU history
        cpu_samples = list(self.cpu_histories[pid])
        if len(cpu_samples) >= 3:
            avg_cpu = sum(cpu_samples) / len(cpu_samples)
            max_cpu = max(cpu_samples)
            
            if avg_cpu < 0.5 and max_cpu < 1.0:
                return 'waiting'  # Waiting for user input
            elif avg_cpu > 5.0:
                return 'running'  # Actively processing
            else:
                return 'idle'     # Minimal activity
        
        # Default to running for new processes
        return 'running'
    
    def sort_instances(self):
        """Sort instances by the current sort key"""
        if self.sort_key == 'pid':
            self.instances.sort(key=lambda x: x.pid, reverse=self.reverse_sort)
        elif self.sort_key == 'cpu':
            self.instances.sort(key=lambda x: x.cpu_percent, reverse=self.reverse_sort)
        elif self.sort_key == 'memory':
            self.instances.sort(key=lambda x: x.memory_mb, reverse=self.reverse_sort)
        elif self.sort_key == 'network':
            self.instances.sort(key=lambda x: x.net_bytes_sent + x.net_bytes_recv, reverse=self.reverse_sort)
        elif self.sort_key == 'disk':
            self.instances.sort(key=lambda x: x.disk_read_bytes + x.disk_write_bytes, reverse=self.reverse_sort)
        elif self.sort_key == 'connections':
            self.instances.sort(key=lambda x: x.connections_count, reverse=self.reverse_sort)
        elif self.sort_key == 'time':
            self.instances.sort(key=lambda x: x.start_time, reverse=self.reverse_sort)

class ClaudeTopUI:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.monitor = ClaudeMonitor()
        self.setup_colors()
        self.error_message = ""
        self.show_help = False
        
    def setup_colors(self):
        """Initialize color pairs"""
        curses.start_color()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Running
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Paused
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)  # High CPU/Memory
        curses.init_pair(4, curses.COLOR_CYAN, curses.COLOR_BLACK)  # Header
        curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLUE)  # Selected
    
    def format_bytes(self, bytes_value):
        """Format bytes into human readable format"""
        if bytes_value == 0:
            return "0B"
        elif bytes_value < 1024:
            return f"{bytes_value}B"
        elif bytes_value < 1024 * 1024:
            return f"{bytes_value/1024:.1f}K"
        elif bytes_value < 1024 * 1024 * 1024:
            return f"{bytes_value/(1024*1024):.1f}M"
        else:
            return f"{bytes_value/(1024*1024*1024):.1f}G"
        
    def draw_header(self):
        """Draw the header with title and stats"""
        height, width = self.stdscr.getmaxyx()
        
        # Title
        title = "═══ Claude-Top - Claude CLI Monitor ═══"
        self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)
        self.stdscr.addstr(0, (width - len(title)) // 2, title)
        self.stdscr.attroff(curses.color_pair(4) | curses.A_BOLD)
        
        # Stats line
        num_instances = len(self.monitor.instances)
        num_running = sum(1 for i in self.monitor.instances if i.status == 'running')
        num_waiting = sum(1 for i in self.monitor.instances if i.status == 'waiting')
        num_idle = sum(1 for i in self.monitor.instances if i.status == 'idle')
        num_paused = sum(1 for i in self.monitor.instances if i.status == 'paused')
        total_tokens = sum(i.tokens_used for i in self.monitor.instances)
        
        stats = f"Instances: {num_instances} | Running: {num_running} | Waiting: {num_waiting} | Idle: {num_idle} | Paused: {num_paused}"
        self.stdscr.addstr(1, 2, stats)
        
        # Column headers with sort indicator
        sort_indicators = {
            'pid': 'PID',
            'cpu': 'CPU%',
            'memory': 'Mem(MB)',
            'tokens': 'Tokens',
            'time': 'Time'
        }
        
        # Build headers with sort indicator - added I/O columns
        headers_parts = [
            ('PID', 7, 'pid'),
            ('Status', 8, None),
            ('CPU%', 6, 'cpu'),
            ('Mem(MB)', 8, 'memory'),
            ('Net↑↓', 8, 'network'),
            ('Disk↑↓', 8, 'disk'),
            ('Conn', 5, 'connections'),
            ('Time', 8, 'time'),
            ('Working Directory', 0, None)
        ]
        
        header_line = ""
        pos = 0
        for label, width, sort_field in headers_parts:
            if sort_field == self.monitor.sort_key:
                # Add sort indicator
                indicator = '▼' if self.monitor.reverse_sort else '▲'
                if width > 0:
                    display_label = f"{label}{indicator}"
                    header_line += f"{display_label:>{width}} "
                else:
                    header_line += f"{label}{indicator}"
            else:
                if width > 0:
                    header_line += f"{label:>{width}} "
                else:
                    header_line += label
        
        self.stdscr.attron(curses.A_UNDERLINE)
        self.stdscr.addstr(3, 0, header_line[:width-1])
        self.stdscr.attroff(curses.A_UNDERLINE)
        
    def draw_instances(self):
        """Draw the list of Claude instances"""
        height, width = self.stdscr.getmaxyx()
        start_y = 4
        visible_lines = height - start_y - 3  # Leave room for footer
        
        for idx, instance in enumerate(self.monitor.instances[:visible_lines]):
            y = start_y + idx
            
            # Highlight selected row
            is_selected = idx == self.monitor.selected_index
            if is_selected:
                self.stdscr.attron(curses.color_pair(5))
            
            # Color based on status
            if instance.status == 'running':
                color = curses.color_pair(1)  # Green
            elif instance.status == 'waiting':
                color = curses.color_pair(4)  # Cyan - waiting for user
            elif instance.status == 'idle':
                color = curses.color_pair(0)  # Default - minimal activity
            elif instance.status == 'paused':
                color = curses.color_pair(2)  # Yellow
            else:
                color = curses.color_pair(0)
            
            # High resource usage warning
            if instance.cpu_percent > 80 or instance.memory_mb > 1000:
                color = curses.color_pair(3)
            
            # Format the row
            elapsed = datetime.now() - instance.start_time
            elapsed_str = f"{elapsed.seconds//3600:02d}:{(elapsed.seconds//60)%60:02d}:{elapsed.seconds%60:02d}"
            
            # Directory display based on setting - expanded width without task column
            if self.monitor.show_full_path:
                dir_display = instance.working_dir
            else:
                # Show last two directories for better context
                parts = instance.working_dir.split('/')
                if len(parts) > 2:
                    dir_display = '/'.join(parts[-2:])
                else:
                    dir_display = instance.working_dir
            
            # Format I/O data
            net_total = instance.net_bytes_sent + instance.net_bytes_recv
            disk_total = instance.disk_read_bytes + instance.disk_write_bytes
            net_display = self.format_bytes(net_total)
            disk_display = self.format_bytes(disk_total)
            
            # Connection display with MCP indicator
            if instance.mcp_connections > 0:
                conn_display = f"{instance.connections_count}M"
            else:
                conn_display = f"{instance.connections_count}"
            
            # Build row with selection indicator - added I/O columns
            if is_selected:
                row = f"→ {instance.pid:>6} {instance.status:>8} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_display:>8} {disk_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
            else:
                row = f"  {instance.pid:>6} {instance.status:>8} {instance.cpu_percent:>6.1f} {instance.memory_mb:>8.1f} {net_display:>8} {disk_display:>8} {conn_display:>5} {elapsed_str:>8} {dir_display}"
            
            self.stdscr.attron(color)
            self.stdscr.addstr(y, 0, row[:width-1])
            self.stdscr.attroff(color)
            
            if is_selected:
                self.stdscr.attroff(curses.color_pair(5))
    
    def draw_footer(self):
        """Draw the footer with commands"""
        height, width = self.stdscr.getmaxyx()
        
        # Error message if any
        if self.error_message:
            self.stdscr.attron(curses.color_pair(3))
            self.stdscr.addstr(height-3, 2, self.error_message[:width-4])
            self.stdscr.attroff(curses.color_pair(3))
        
        # Commands
        commands = "q:Quit  p:Pause/Resume  k:Kill  s:Sort  f:Path  h:Help  ↑↓:Navigate"
        self.stdscr.addstr(height-1, 2, commands[:width-4])
    
    def draw_help(self):
        """Draw help overlay"""
        height, width = self.stdscr.getmaxyx()
        help_text = [
            "Claude-Top Help",
            "",
            "Navigation:",
            "  ↑/↓ or j/k  - Move selection up/down",
            "  Home/End    - Go to first/last item",
            "",
            "Actions:",
            "  p           - Pause/Resume selected instance",
            "  k           - Kill selected instance",
            "  f           - Toggle full/short directory path",
            "  Enter       - View detailed information",
            "",
            "Sorting:",
            "  s           - Cycle: PID→CPU→Memory→Network→Disk→Connections→Time",
            "  r           - Reverse sort order",
            "",
            "Display Columns:",
            "  Net↑↓       - Total network I/O (sent + received)",
            "  Disk↑↓      - Total disk I/O (read + write)",
            "  Conn        - Network connections (M = MCP detected)",
            "",
            "Controls:",
            "  h           - Toggle this help",
            "  q or Esc    - Quit",
            "",
            "Press any key to close help..."
        ]
        
        # Calculate box dimensions
        box_height = len(help_text) + 4
        box_width = max(len(line) for line in help_text) + 6
        start_y = (height - box_height) // 2
        start_x = (width - box_width) // 2
        
        # Draw box
        self.stdscr.attron(curses.color_pair(4))
        for y in range(box_height):
            self.stdscr.addstr(start_y + y, start_x, " " * box_width)
        
        # Draw help text
        for i, line in enumerate(help_text):
            self.stdscr.addstr(start_y + i + 2, start_x + 3, line)
        self.stdscr.attroff(curses.color_pair(4))
    
    def handle_input(self):
        """Handle keyboard input"""
        key = self.stdscr.getch()
        
        if self.show_help:
            # Wait for any key press to close help
            if key != -1:
                self.show_help = False
            return True
        
        if key == ord('q') or key == 27:  # q or ESC
            return False
        elif key == ord('h'):
            self.show_help = True
        elif key == curses.KEY_UP or key == ord('k'):
            if self.monitor.selected_index > 0:
                self.monitor.selected_index -= 1
        elif key == curses.KEY_DOWN or key == ord('j'):
            if self.monitor.selected_index < len(self.monitor.instances) - 1:
                self.monitor.selected_index += 1
        elif key == ord('p'):
            # Pause/Resume selected instance
            if self.monitor.instances:
                instance = self.monitor.instances[self.monitor.selected_index]
                error = self.monitor.pause_resume_process(instance.pid)
                if error:
                    self.error_message = error
                else:
                    self.error_message = ""
        elif key == ord('s'):
            # Cycle through sort options - added I/O columns
            sort_options = ['pid', 'cpu', 'memory', 'network', 'disk', 'connections', 'time']
            current_idx = sort_options.index(self.monitor.sort_key)
            self.monitor.sort_key = sort_options[(current_idx + 1) % len(sort_options)]
            self.monitor.sort_instances()
        elif key == ord('r'):
            # Reverse sort order
            self.monitor.reverse_sort = not self.monitor.reverse_sort
        
        elif key == ord('f') or key == ord('F'):
            # Toggle full path display
            self.monitor.show_full_path = not self.monitor.show_full_path
            self.monitor.sort_instances()
        
        return True
    
    def run(self):
        """Main UI loop"""
        self.stdscr.nodelay(True)  # Non-blocking input
        curses.curs_set(0)  # Hide cursor
        
        last_update = 0
        running = True
        
        while running:
            current_time = time.time()
            
            # Update data periodically
            if current_time - last_update > self.monitor.update_interval:
                self.monitor.instances = self.monitor.find_claude_processes()
                self.monitor.sort_instances()
                last_update = current_time
                
                # Clean up old CPU histories
                current_pids = {inst.pid for inst in self.monitor.instances}
                self.monitor.cpu_histories = {pid: hist for pid, hist in self.monitor.cpu_histories.items() if pid in current_pids}
                
                # Adjust selected index if needed
                if self.monitor.selected_index >= len(self.monitor.instances):
                    self.monitor.selected_index = max(0, len(self.monitor.instances) - 1)
            
            # Clear and redraw
            self.stdscr.clear()
            
            if self.show_help:
                self.draw_help()
            else:
                self.draw_header()
                self.draw_instances()
                self.draw_footer()
            
            self.stdscr.refresh()
            
            # Handle input
            running = self.handle_input()
            
            # Small delay to prevent high CPU usage
            time.sleep(0.05)

def main(stdscr):
    """Main entry point"""
    ui = ClaudeTopUI(stdscr)
    ui.run()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Monitor Claude CLI instances")
    parser.add_argument('--interval', type=float, default=1.0, help="Update interval in seconds")
    args = parser.parse_args()
    
    try:
        curses.wrapper(main)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
